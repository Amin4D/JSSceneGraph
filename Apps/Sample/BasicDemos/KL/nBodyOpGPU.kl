
//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

function initOpenCL
(
  io cl_context clContext,
  io cl_command_queue clCommandQueue,
  io cl_kernel clKernel,
  io Size clLocal,
  in String kernelSrc
) {
  if (!clContext) {
    var Integer clErr;

    clContext = clCreateContext_GL(clErr);

    cl_device_id clContextDeviceIDs[];
    clErr = clGetContextDevices(clContext, clContextDeviceIDs);
    report "clGetContextDevices: " + clErr;
    
    cl_device_id clDeviceID = clContextDeviceIDs[0];
    for ( Size i=0; i<clContextDeviceIDs.size; ++i )
    {
      cl_device_type clDeviceType;
      clErr = clGetDeviceType( clContextDeviceIDs[i], clDeviceType );
      report "clGetDeviceType: " + clErr;
      if ( clDeviceType == CL_DEVICE_TYPE_GPU )
      {
        report "Found GPU device at index " + i;
        clDeviceID = clContextDeviceIDs[i];
        break;
      }
    }
    report "clDeviceID = " + clDeviceID + " (" + (Boolean)clDeviceID + ")";
    cl_device_id clDeviceIDs[];
    clDeviceIDs.push(clDeviceID);

    clCommandQueue = clCreateCommandQueue(clContext, clDeviceID, 0, clErr);
    report "clCreateCommandQueue: " + clErr;
    report "clCommandQueue = " + clCommandQueue + " (" + (Boolean)clCommandQueue + ")";
  
    var cl_program clProgram = clCreateProgramWithSource(clContext, kernelSrc, clErr);
    report "clCreateProgramWithSource: " + clErr;
    report "clProgram = " + clProgram + " (" + (Boolean)clProgram + ")";
    
    clErr = clBuildProgram(clProgram, clDeviceIDs, '');
    report "clBuildProgram: " + clErr;
    if (clErr) {
      var String infoStr;
      clGetProgramBuildInfoStr(clProgram, clDeviceID, CL_PROGRAM_BUILD_LOG, infoStr);
      report('...OpenCL build failed: ' + infoStr);
    }

    clKernel = clCreateKernel(clProgram, 'integrateBodies_MT', clErr);
    var Data NULL;
    clGetKernelWorkGroupInfo(clKernel, clDeviceID, CL_KERNEL_WORK_GROUP_SIZE, clLocal.dataSize, clLocal.data, NULL);
  }
}

operator nBodySimulateGPU(
  io Scalar time,
  io Vec4 posInit[],
  io Vec3 velInit[],
  io Scalar massInit[],

  io cl_context clContext,
  io cl_command_queue clCommandQueue,
  io cl_kernel clKernel,
  io String kernelSrc,
  io Integer posOpenGLBufferID,
  io cl_mem posCurrent,
  io cl_mem velCurrent,
  io cl_mem posPrev,
  io cl_mem velPrev,
  io Size clPointCount,

  io Scalar timeStep,
  io Scalar softening,
  io Scalar damping
) {
  var Data NULL;
  var Integer clErr;
  var cl_event eventWaitList[];
  var cl_event event;

  if (!clContext) {
    var Size clLocal;

    initOpenCL(clContext, clCommandQueue, clKernel, clLocal, kernelSrc);
  }

  if (time == 0.0) {
    if (clPointCount != posInit.size()) {
      if (posInit.size() > 255) {
        clPointCount = posInit.size() & ~255;
      }
      else {
        clPointCount = posInit.size();
      }
      if (posCurrent) {
        clReleaseMemObject(posCurrent);
        clReleaseMemObject(velCurrent);
        clReleaseMemObject(posPrev);
        clReleaseMemObject(velPrev);
      }
      var Size memSize = clPointCount * 4 * 4; // float * 4
      // TODO: Always check the error values.
      report 'posOpenGLBufferID = ' + posOpenGLBufferID;
      posCurrent = clCreateFromGLBuffer(clContext, CL_MEM_READ_WRITE, posOpenGLBufferID, clErr);
      report 'clCreateFromGLBuffer: ' + clErr;
      Size posCurrentSize;
      clErr = clGetMemObjectSize(posCurrent, posCurrentSize);
      report 'posCurrentSize = ' + posCurrentSize;
      report 'posCurrent = ' + posCurrent + '(' + (Boolean)posCurrent + ')';

      velCurrent = clCreateBuffer(clContext, CL_MEM_READ_WRITE, memSize, NULL, clErr);
      Size velCurrentSize;
      clErr = clGetMemObjectSize(velCurrent, velCurrentSize);
      report 'velCurrentSize = ' + velCurrentSize;
      posPrev = clCreateBuffer(clContext, CL_MEM_READ_WRITE, memSize, NULL, clErr);
      velPrev = clCreateBuffer(clContext, CL_MEM_READ_WRITE, memSize, NULL, clErr);
    }

    var Vec4 writeData[];

    writeData.resize(clPointCount);

    for (var Size i = 0; i < clPointCount; i++) {
      writeData[i].x = posInit[i].x;
      writeData[i].y = posInit[i].y;
      writeData[i].z = posInit[i].z;
      writeData[i].t = massInit[i];
    }
    clErr = clEnqueueWriteBuffer(clCommandQueue, posPrev, CL_TRUE, 0, writeData.dataSize, writeData.data, eventWaitList, event);

    for (var Size i = 0; i < clPointCount; i++) {
      writeData[i].x = velInit[i].x;
      writeData[i].y = velInit[i].y;
      writeData[i].z = velInit[i].z;
      writeData[i].t = 1.0 / massInit[i];
    }
    clErr = clEnqueueWriteBuffer(clCommandQueue, velPrev, CL_TRUE, 0, writeData.dataSize, writeData.data, eventWaitList, event);
  }
  else {
    var cl_mem temp;
    temp = posPrev;
    posPrev = posCurrent;
    posCurrent = temp;

    temp = velPrev;
    velPrev = velCurrent;
    velCurrent = temp;
  }

  // Run the kernel and simulate
  var Scalar softeningSq = softening * softening;

  cl_mem memsToAcquire[];
  memsToAcquire.push(posCurrent);

  clErr = clEnqueueAcquireGLObjects(clCommandQueue, memsToAcquire, eventWaitList, event);
  //report 'clEnqueueAcquireGLObjects: ' + clErr;

  // - Compute the local tile size for the single-multiple body interaction
  var Integer p = 256, q = 1;
  if (clPointCount < p && q == 1) {
    p = clPointCount;
  }
  var Size sharedMemSize = p * q * 4; // sizeof( float )

  clErr = clSetKernelArg(clKernel, 0, posCurrent.dataSize, posCurrent.data);
  clErr = clSetKernelArg(clKernel, 1, velCurrent.dataSize, velCurrent.data);
  clErr = clSetKernelArg(clKernel, 2, posPrev.dataSize, posPrev.data);
  clErr = clSetKernelArg(clKernel, 3, velPrev.dataSize, velPrev.data);

  clErr = clSetKernelArg(clKernel, 4, timeStep.dataSize, timeStep.data);
  clErr = clSetKernelArg(clKernel, 5, damping.dataSize, damping.data);
  clErr = clSetKernelArg(clKernel, 6, softeningSq.dataSize, softeningSq.data);

  clErr = clSetKernelArg(clKernel, 7, clPointCount.dataSize, clPointCount.data);

  clErr = clSetKernelArg(clKernel, 8, sharedMemSize, NULL);

  var Size localWorkSize[2], globalWorkSize[2];
  localWorkSize[0] = p;
  localWorkSize[1] = q;
  globalWorkSize[0] = clPointCount;
  globalWorkSize[1] = q;

  clErr = clEnqueueNDRangeKernel(clCommandQueue, clKernel, 2, NULL, globalWorkSize.data, localWorkSize.data, eventWaitList, event);
  //report 'clEnqueueNDRangeKernel: ' + clErr;

  clErr = clEnqueueReleaseGLObjects(clCommandQueue, memsToAcquire, eventWaitList, event);
  //report 'clEnqueueReleaseGLObjects: ' + clErr;

  clErr = clFinish(clCommandQueue);
  //report 'clFinish: ' + clErr;
}