
#include '../../../SceneGraph/Resources/KL/evaluateKeyframeAnimationTrack.kl'

operator presimulateMuscle(
  io Scalar restLength,
  io Scalar contractionFactor,
  io Xfo segmentXfos[],
  io BezierKeyframe contractionCurve[]
){
  Scalar scale = restLength / segmentXfos[0].tr.dist(segmentXfos[segmentXfos.size()-1].tr);
  Integer keyIndex = -1;
  contractionFactor = evaluateKeyframeAnimationTrack(contractionCurve, scale, keyIndex);
}

operator bindMuscleToSkeleton(
  io Xfo segmentXfos[],
  io Vec3 pointPositionsPrevUpdate[],
  io Vec3 pointPositionsPrevUpdate_Temp[],
){


}

operator simulateMuscle(
  io Xfo initialXfos[], /* inital Transforsm  */
  io Scalar segmentLengths[],
  io Vec2 pointEnvelopeIds,
  io Vec2 pointEnvelopWeights[],
  io Scalar flexibilityWeights[], /* weights determining how much the muscle is simulated. */
  io BezierKeyframe contractionCurve[],
  
  io Boolean initialized,
  io Xfo envelopedXfos[], /* Xfos deformed by the skeleton  */
  io Xfo simulatedXfos[], /* Xfos simulated and used to drive the skin deformation */
  io Scalar segmentCompressionFactors[],
  
  io Vec3 pointPositionsPrevUpdate[],
  io Vec3 pointPositionsPrevUpdate_Temp[],
  io Integer numRelaxationIterations,
  
  io Vec3 gravity,
  io Scalar deltaT,
  io Xfo skeletonXfos[]
){
  Integer i, j;
  if(initialized || pointPositionsPrevUpdate.size() != simulatedXfos.size()){
    pointPositionsPrevUpdate.resize(simulatedXfos.size());
    pointPositionsPrevUpdate_Temp.resize(simulatedXfos.size());
    for(i=0; i<initialXfos.size(); i++){
      simulatedXfos[i] = initialXfos[i];
      pointPositionsPrevUpdate[i] = initialXfos[i].tr;
    }
  }
  
  for(i=0; i<simulatedXfos.size(); i++){
    pointPositionsPrevUpdate_Temp[i] = simulatedXfos[i].tr;
  }
  
  // Envelope the xfos to the skeleton using basic enveloping math.
  for(i=0; i<simulatedXfos.size(); i++){
    envelopedXfos[i] = Xfo();
    if (pointEnvelopWeights[j].x > 0.0) {
      envelopedXfos[i].tr += (skeletonXfos[Integer(pointEnvelopeIds.x)].transform(initialXfos[i].tr)) * pointEnvelopWeights[j].x;
      envelopedXfos[i].ori += (initialXfos[i].ori * skeletonXfos[Integer(pointEnvelopeIds.x)].ori) * pointEnvelopWeights[j].x;
    }
    if (pointEnvelopWeights[j].y > 0.0) {
      envelopedXfos[i].tr += (skeletonXfos[Integer(pointEnvelopeIds.y)].transform(initialXfos[i].tr)) * pointEnvelopWeights[j].y;
      envelopedXfos[i].ori += (initialXfos[i].ori * skeletonXfos[Integer(pointEnvelopeIds.y)].ori) * pointEnvelopWeights[j].y;
    }
    envelopedXfos[i].ori.normalize();
  }
  
  // Measure the distance from the 2 anchor points of the muscle.
  // Use this to look up the curve and calculate the current contraction of the muscle
  Scalar contractionFactor = envelopedXfos[0].tr.dist(envelopedXfos[envelopedXfos.size()-1].tr) /
                               initialXfos[0].tr.dist(initialXfos[initialXfos.size()-1].tr);
  Integer keyIndex = -1;
  contractionFactor = evaluateKeyframeAnimationTrack(contractionCurve, contractionFactor, keyIndex);
  
  // Increment the muscle system using basic Verlet simulation.
  for(i=0; i<simulatedXfos.size(); i++){
    simulatedXfos[i].tr += (gravity / (deltaT * deltaT)) + (simulatedXfos[i].tr - pointPositionsPrevUpdate[i]);
    simulatedXfos[i].tr = envelopedXfos[i].tr.lerp(simulatedXfos[i].tr, flexibilityWeights[i]);
  }
  
  // Now relax the muscle iteratively maintaining the original segment lengths.
  for(i=0; i<numRelaxationIterations; i++){
    for( j=0; j<simulatedXfos.size()-1; j++){
      Vec3 delta(0.0, 0.0, 0.0);
      if(j>0){
        Vec3 segment = (simulatedXfos[j].tr - simulatedXfos[j-1].tr);
        Scalar segmentLength = segment.length();
        delta += (segment * (segmentLength - (segmentLengths[j] * contractionFactor)) / segmentLength);
      }
      if(j<simulatedXfos.size()-1){
        Vec3 segment = (simulatedXfos[j+1].tr - simulatedXfos[j].tr);
        Scalar segmentLength = segment.length();
        delta += (segment * (segmentLength - (segmentLengths[j] * contractionFactor)) / segmentLength);
      }
      simulatedXfos[j].tr += delta;
    }
  }
  
  // Align the quaternions to the muscle segments
  for(i=0; i<simulatedXfos.size(); i++){
    simulatedXfos[i].ori = envelopedXfos[i].ori * makeQuatFrom2Vectors( envelopedXfos[i].ori.rotateVector(Vec3(1.0, 0.0, 0.0)), (simulatedXfos[i].tr - pointPositionsPrevUpdate[i]).unit());
  }
  
  // Now measure how much each segment has compressed/stretched
  // this is used to control the bulging/volume preservation of the muscle
  for(i=1; i<simulatedXfos.size()-1; i++){
    segmentCompressionFactors[i] = (simulatedXfos[i].tr - simulatedXfos[i-1].tr).length() / segmentLengths[i];
  }
  
  for(i=0; i<simulatedXfos.size(); i++){
    pointPositionsPrevUpdate[i] = pointPositionsPrevUpdate_Temp[i];
  }
}


