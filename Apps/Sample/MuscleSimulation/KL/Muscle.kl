
#include '../../../SceneGraph/Resources/KL/evaluateKeyframeAnimationTrack.kl'


operator simulateMuscle(
  io Xfo initialXfos[], /* inital Transforsm  */
  io Xfo baseMuscleXfo,
  io Scalar segmentLengths[],
  io Vec2 pointEnvelopeIds,
  io Vec2 pointEnvelopWeights[],
  io Scalar flexibilityWeights[], /* weights determining how much the muscle is simulated. */
  io BezierKeyframe contractionCurve[],
  
  io Boolean initialized,
  io Xfo envelopedXfos[], /* Xfos deformed by the skeleton  */
  io Xfo simulatedXfos[], /* Xfos simulated and used to drive the skin deformation */
  io Scalar segmentCompressionFactors[],
  
  io Vec3 pointPositionsPrevUpdate[],
  io Vec3 pointPositionsPrevUpdate_Temp[],
  io Integer numRelaxationIterations,
  
  io Vec3 gravity,
  io Scalar timeStep,
  io Xfo skeletonXfos[]
){
//  report("simulateMuscle>>>");
  Integer i, j;
  Xfo baseXfo, xfo;
  
  if(!initialized || pointPositionsPrevUpdate.size() != simulatedXfos.size()){
    report("!initialized");
    envelopedXfos.resize(initialXfos.size());
    simulatedXfos.resize(initialXfos.size());
    segmentCompressionFactors.resize(initialXfos.size());
    pointPositionsPrevUpdate.resize(initialXfos.size());
    pointPositionsPrevUpdate_Temp.resize(initialXfos.size());
    for(i=0; i<initialXfos.size(); i++){
      simulatedXfos[i] = initialXfos[i];
      pointPositionsPrevUpdate[i] = initialXfos[i].tr;
    }
    initialized = false;
  }
  
  /////////////////////////////////////////////////
  // Enveloping/Skinning
  // Envelope the xfos to the skeleton using basic enveloping math.
  Vec3 v3(0.0,0.0,0.0);
  for(i=0; i<simulatedXfos.size(); i++){
    baseXfo = baseMuscleXfo * initialXfos[i];
    envelopedXfos[i].identity();
    if (pointEnvelopWeights[i].x > 0.0) {
        xfo = baseXfo * skeletonXfos[Integer(pointEnvelopeIds.x)];
        envelopedXfos[i].tr += xfo.tr * pointEnvelopWeights[i].x;
        envelopedXfos[i].ori += xfo.ori * pointEnvelopWeights[i].x;
    }
    if (pointEnvelopWeights[i].y > 0.0) {
        xfo = baseXfo * skeletonXfos[Integer(pointEnvelopeIds.y)];
        envelopedXfos[i].tr += xfo.tr * pointEnvelopWeights[i].y;
        envelopedXfos[i].ori += xfo.ori * pointEnvelopWeights[i].y;
    }
    envelopedXfos[i].ori.normalize();
  }
  
  // Measure the distance from the 2 anchor points of the muscle.
  // Use this to look up the curve and calculate the current contraction of the muscle
  Scalar contractionFactor = envelopedXfos[0].tr.dist(envelopedXfos[envelopedXfos.size()-1].tr) /
                               initialXfos[0].tr.dist(initialXfos[initialXfos.size()-1].tr);
  Integer keyIndex = 0;
  contractionFactor = evaluateKeyframeAnimationTrack(contractionCurve, contractionFactor, keyIndex);
  
  /////////////////////////////////////////////////
  // Simulation
  if(!initialized){
    for(i=0; i<initialXfos.size(); i++){
      simulatedXfos[i] = envelopedXfos[i];
    }
    initialized = true;
  }
  
  for(i=0; i<simulatedXfos.size(); i++){
    pointPositionsPrevUpdate_Temp[i] = simulatedXfos[i].tr;
  }
  
  // Increment the muscle system using basic Verlet simulation.
  if(timeStep>0){
    for(i=0; i<simulatedXfos.size(); i++){
      // When under contraction, we remove gravity.
      // Its a bit of a hack to exagerate the strength of the contraction
      simulatedXfos[i].tr += ((gravity / (timeStep * timeStep)) * contractionFactor) + (simulatedXfos[i].tr - pointPositionsPrevUpdate[i]);
      simulatedXfos[i].tr = envelopedXfos[i].tr.lerp(simulatedXfos[i].tr, flexibilityWeights[i]);
    }
  }
  
  // Now relax the muscle iteratively maintaining the original segment lengths.
  Vec3 deltas[];
  Vec3 delta;
  deltas.resize(simulatedXfos.size());
  for(j=0; j<numRelaxationIterations; j++){
    for( i=0; i<simulatedXfos.size(); i++){
      delta.setNull();
      if(i>0){
        Vec3 segmentPrev = (simulatedXfos[i-1].tr - simulatedXfos[i].tr);
        Scalar segmentLength = segmentPrev.length();
        delta += segmentPrev * ((segmentLength - (segmentLengths[i-1] * contractionFactor)) / segmentLength);
      }
      if(i<simulatedXfos.size()-1){
        Vec3 segmentNext = (simulatedXfos[i+1].tr - simulatedXfos[i].tr);
        Scalar segmentLength = segmentNext.length();
        delta += segmentNext * ((segmentLength - (segmentLengths[i] * contractionFactor)) / segmentLength);
      }
      deltas[i] = delta;
    }
    for( i=0; i<simulatedXfos.size(); i++){
      simulatedXfos[i].tr += deltas[i] * (flexibilityWeights[i] * 0.45);// The 0.45 stabilizes the simulation.;
    }
  }
  
  
  for(i=0; i<simulatedXfos.size(); i++){
    pointPositionsPrevUpdate[i] = pointPositionsPrevUpdate_Temp[i];
  }
  /////////////////////////////////////////////////
  // Frame Alignement
  /*
  // Align the quaternions to the muscle segments
  for(i=0; i<simulatedXfos.size(); i++){
    Quat alignementQuat = makeQuatFrom2Vectors( envelopedXfos[i].ori.rotateVector(Vec3(1.0, 0.0, 0.0)),
                                               (simulatedXfos[i].tr - pointPositionsPrevUpdate[i]).unit());
    simulatedXfos[i].ori = envelopedXfos[i].ori * alignementQuat;
  }
  */
  
  // Now measure how much each segment has compressed/stretched
  // this is used to control the bulging/volume preservation of the muscle
  for(i=1; i<simulatedXfos.size()-1; i++){
    segmentCompressionFactors[i] = (simulatedXfos[i].tr - simulatedXfos[i-1].tr).length() / segmentLengths[i];
  }
  
//  report("simulateMuscle<<<");
}


