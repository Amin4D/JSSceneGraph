
//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

use Math;
use Color;

function DisplacementMap(Color pixels[], Size size) {
  this.pixels = pixels;
  this.size = size;
}

function DisplacementMap.resize(Size size) {
  this.pixels.resize(size * size);
  this.size = size;
}

function Size DisplacementMap.uvToPixelIndex(Scalar u, Scalar v) {
  Integer uindex = Integer(u * Scalar(this.size-1));
  Integer vindex = Integer(v * Scalar(this.size-1));
  return (vindex * this.size) + uindex;
}


function DisplacementMap.setValue(Scalar u, Scalar v, Color val) {
  this.pixels[this.uvToPixelIndex(u,v)] = val; 
}

function DisplacementMap.setRValue(Scalar u, Scalar v, Scalar val) {
  this.pixels[this.uvToPixelIndex(u,v)].r = val; 
}

function DisplacementMap.setGValue(Scalar u, Scalar v, Scalar val) {
  this.pixels[this.uvToPixelIndex(u,v)].g = val; 
}

function DisplacementMap.setBValue(Scalar u, Scalar v, Scalar val) {
  this.pixels[this.uvToPixelIndex(u,v)].b = val; 
}

// Use bi-linear interpollation to calculate the resulting pixel value. 
function Color DisplacementMap.getValue(Scalar u, Scalar v) {
  Scalar u_denorm = u * Scalar(this.size-1);
  Scalar v_denorm = v * Scalar(this.size-1);
  
  Scalar u_fract = u_denorm - floor(u_denorm);
  Scalar v_fract = v_denorm - floor(v_denorm);
  Integer uindex = Integer(floor(u_denorm));
  Integer vindex = Integer(floor(v_denorm));
  
  Color val1 = this.pixels[(vindex * this.size) + uindex].lerp(this.pixels[(vindex * this.size) + uindex+1], u_fract);
  Color val2 = this.pixels[((vindex+1) * this.size) + uindex].lerp(this.pixels[((vindex+1) * this.size) + uindex+1], u_fract);
  return val1.lerp(val2, v_fract);
}

function Color DisplacementMap.getValue(Vec2 uv) {
  return this.getValue(uv.x,uv.y);
}

