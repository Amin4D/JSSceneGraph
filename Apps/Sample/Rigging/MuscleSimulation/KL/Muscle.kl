
//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

use Math;
use Color;

function DisplacementMap(Color pixels[], Size size) {
  this.pixels = pixels;
  this.size = size;
}

function DisplacementMap.resize(Size size) {
  this.pixels.resize(size * size);
  this.size = size;
}

function Size DisplacementMap.uvToPixelIndex(Scalar u, Scalar v) {
  Integer uindex = Integer(u * Scalar(this.size));
  Integer vindex = Integer(v * Scalar(this.size));
  if(uindex == this.size){
    uindex = (this.size-1); // CLAMP;
  }
  if(vindex == this.size){
    vindex = 0; // LOOP;
  }
  return (vindex * this.size) + uindex;
}


function DisplacementMap.setValue(Scalar u, Scalar v, Color val) {
  this.pixels[this.uvToPixelIndex(u,v)] = val; 
}

function DisplacementMap.setRValue(Scalar u, Scalar v, Scalar val) {
  this.pixels[this.uvToPixelIndex(u,v)].r = val; 
}

function Color DisplacementMap.getPixel(Integer u, Integer v) {
  Integer uindex = u;
  Integer vindex = v;
  if(uindex == this.size){
    uindex = (this.size-1); // CLAMP;
  }
  if(vindex == this.size){
    vindex = 0; // LOOP;
  }
  return this.pixels[(vindex * this.size) + uindex];
}

// Use bi-linear interpollation to calculate the resulting pixel value. 
function Color DisplacementMap.getValue(Scalar u, Scalar v) {
  Scalar u_denorm = u * Scalar(this.size-1);
  Scalar v_denorm = v * Scalar(this.size-1);
  
  Scalar u_fract = u_denorm - floor(u_denorm);
  Scalar v_fract = v_denorm - floor(v_denorm);
  Integer uindex = Integer(floor(u_denorm));
  Integer vindex = Integer(floor(v_denorm));
  
  Color val1 = this.getPixel(uindex, vindex  ).lerp(this.getPixel(uindex+1, vindex  ), u_fract);
  Color val2 = this.getPixel(uindex, vindex+1).lerp(this.getPixel(uindex+1, vindex+1), u_fract);
  return val1.lerp(val2, v_fract);
}

function Color DisplacementMap.getValue(Vec2 uv) {
  return this.getValue(uv.x,uv.y);
}

