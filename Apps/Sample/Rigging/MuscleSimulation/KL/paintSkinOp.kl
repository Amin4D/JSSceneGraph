//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

use CollectedPoints;
use Mat33;
use Mat44;
use Vec3;
use Xfo;
use Color;

operator paintSkinWeights(
  io Boolean select,
  io CollectedPoints collectedPoints,

  io Mat44 cameraMatrix,
  io Mat44 projectionMatrix,
  io Scalar aspectRatio,

  io Vec3 brushPos,
  io Scalar brushSize,
  io Integer mode,

  io Xfo globalXfo,
  io Vec3 positions<>,
  io Vec3 normals<>,
  
  io Scalar stickWeights<>,
  io Scalar slideWeights<>,
  io Scalar bulgeWeights<>
) {
  Mat44 modelMatrix = globalXfo;
  Mat44 modelViewProjectionMatrix = modelMatrix * cameraMatrix * projectionMatrix;
  Mat33 normalMatrix = modelViewProjectionMatrix.upperLeft().inverse().transpose();

  for (var Integer i = 0; i < positions.size(); i++) {
    Vec3 n = normals[i] * normalMatrix;
    if (n.z > 0) {
      continue;
    }
    Vec3 v = positions[i] * modelViewProjectionMatrix;
    Vec3 delta = v - brushPos;
    delta.x *= aspectRatio;
    delta.z *= 0.0;
    Scalar dist = delta.norm();

    if (dist < brushSize) {
      collectedPoints.distances.push(dist);
      collectedPoints.points.push(i);
    }
  }

  // Rather than returning the data back to JavaScript, we process them here,
  // calculating the new vertex color values based on thier distances from the paint brush
  var Scalar Pi = 3.141592653589793238462643;

  for (var Integer i = 0; i < collectedPoints.points.size(); i++) {
    Scalar weight = (cos(Pi * (collectedPoints.distances[i] / brushSize)) * 0.5) + 0.5;
    Integer vertexId = collectedPoints.points[i];
    switch(mode){
    case 0: 
      stickWeights[vertexId] += ((1.0 - stickWeights[vertexId]) * weight);
      break;
    case 1: 
      slideWeights[vertexId] += ((1.0 - slideWeights[vertexId]) * weight);
      break;
    case 2: 
      bulgeWeights[vertexId] += ((1.0 - bulgeWeights[vertexId]) * weight);
      break;
    }
    
  }
}