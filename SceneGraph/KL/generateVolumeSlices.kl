//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

use Xfo;

operator generateVolumeSlices(
  io Vec3 volumeMin,
  io Vec3 volumeMax,
  io Size nbSlices,
  io Xfo volumeXfo,
  io Mat44 camera,
  io Mat44 projection,
  io Integer indices[],
  io Vec3 positions<>,
  io Vec3 normals<>
){
  indices.resize(0);

  if(nbSlices == 0)
    return;

  Vec3 volSize = volumeMax - volumeMin;
  if(volSize.x < PRECISION || volSize.y < PRECISION || volSize.z < PRECISION)
    return;

  Vec3 invVolSize = volSize.inverse();

  report( "generateVolumeSlices\n" );
  report( "nbSlices: " + nbSlices + "\n" );
  report( "camera: " + camera + "\n");
  report( "projection: " + projection + "\n" );

  Mat44 volInv = volumeXfo.toMat44().inverse();
  Mat44 camInv = camera.inverse();
  Vec3 camPos = camInv.translation();
  report( "camPos " + camPos + "\n");

  Mat44 camProjInv = volInv * camInv * projection.inverse();
  Vec3 camRange[2];
  camRange[0] = camProjInv * Vec3(0.0, 0.0, -1.0);
  camRange[1] = camProjInv * Vec3(0.0, 0.0, 1.0);

  Vec3 camDir = (camRange[1] - camRange[0]);
  Scalar camDepth = camDir.length();
  camDir /= camDepth;
  Vec3 camYPos = camProjInv * Vec3(0.0, 0.5, -1.0);
  Vec3 biasedCamDir = ((camYPos - camRange[0]).unit() * 0.25 + camDir).unit();

  //Find the camera-aligned slice depth
  Vec3 volume[2];
  volume[0] = volumeMin;
  volume[1] = volumeMax;

  Vec3 camMinVolBBox[2];
  Size i, j, k;
  for(i = 0; i <3; ++i) {
    if(camDir.component(i) < 0) {
      camMinVolBBox[1].setComponent(i, volume[0].component(i));
      camMinVolBBox[0].setComponent(i, volume[1].component(i));
    }
    else {
      camMinVolBBox[0].setComponent(i, volume[0].component(i));
      camMinVolBBox[1].setComponent(i, volume[1].component(i));
    }
  }
  Scalar depthRange[2];
  for(i = 0; i <2; ++i) {
    depthRange[i] = (camMinVolBBox[i] - camRange[0]).dot(camDir);
    depthRange[i] = Math_clamp(depthRange[i], 0, camDepth);
  }
  Scalar depth = depthRange[1] - depthRange[0];
  Scalar relativePrecision = PRECISION * depthRange[1];

  if(abs(depth) < relativePrecision)
    return;

  Scalar step = depth / Scalar(nbSlices);
  Scalar invStep = 1.0 / step;

  report(" curr " + curr + " step " + step);

  Vec3 points[8], texCoords[8];
  Scalar pointsDepth[8];
  Size pointDepthOrder[8];
  Size index = 0;
  for(i = 0; i < 2; ++i) {
    for(j = 0; j < 2; ++j) {
      for(k = 0; k < 2; ++k) {
        points[index].set(volume[k].x, volume[j].y, volume[i].z);
        texCoords[index].set(Scalar(i), Scalar(j), Scalar(k));
        pointsDepth[index] = (points[index]-camRange[0]).dot(camDir);
        pointDepthOrder[index] = index;
        ++index;
      }
    }
  }

  //Sort points along cam inverse direction - back to front (simple bubble sort)
  for(i = 0; i < 8; ++i) {
    for(j = i+1; j < 8; ++j) {
      Size first = pointDepthOrder[i];
      Size second = pointDepthOrder[j];
      Scalar firstDepth = pointsDepth[first];
      Scalar secondDepth = pointsDepth[second];
      if(abs(firstDepth - secondDepth) < relativePrecision) {
        //Cam dir is axis-aligned; this is an exceptional case where we must ensure that coplanar 
        //points are sorted in coherent order (adjacency wise). A simple way to achieve this is to
        //sort according to a biased camDir:
        firstDepth = (points[first]-camRange[0]).dot(biasedCamDir);
        secondDepth = (points[first]-camRange[0]).dot(biasedCamDir);
      }
      if(pointsDepth[second] > pointsDepth[first]){
        pointDepthOrder[i] = second;
        pointDepthOrder[j] = first;
      }
    }
  }
  report "Order: " + pointDepthOrder;

  //constant cube topology
  Size pointCCWEdges[8][3];
  pointCCWEdges[0][0] = 0;pointCCWEdges[0][1] = 4;pointCCWEdges[0][2] = 3;
  pointCCWEdges[1][0] = 0;pointCCWEdges[1][1] = 1;pointCCWEdges[1][2] = 2;
  pointCCWEdges[2][0] = 3;pointCCWEdges[2][1] = 8;pointCCWEdges[2][2] = 11;
  pointCCWEdges[3][0] = 5;pointCCWEdges[3][1] = 9;pointCCWEdges[3][2] = 8;
  pointCCWEdges[4][0] = 2;pointCCWEdges[4][1] = 7;pointCCWEdges[4][2] = 3;
  pointCCWEdges[5][0] = 6;pointCCWEdges[5][1] = 1;pointCCWEdges[5][2] = 2;
  pointCCWEdges[6][0] = 7;pointCCWEdges[6][1] = 11;pointCCWEdges[6][2] = 10;
  pointCCWEdges[7][0] = 6;pointCCWEdges[7][1] = 10;pointCCWEdges[7][2] = 9;

  Vec3 edgeAxis[12];
  edgeAxis[0] = edgeAxis[8] = edgeAxis[2] = edgeAxis[10] = 0;
  edgeAxis[4] = edgeAxis[5] = edgeAxis[6] = edgeAxis[7] = 1;
  edgeAxis[1] = edgeAxis[9] = edgeAxis[3] = edgeAxis[11] = 2;

  Scalar axisSteps[3];
  Scalar axisTexCoordSteps[3];
  Scalar axisInvLen[3];

  for(i = 0; i < 3; ++i){
    Scalar dot = camDir.component(i);
    if(dot > DIVIDEPRECISION)
      axisSteps[i] = step / dot;
    else
      axisSteps[i] = 1;//in fact we won't use it...
    axisInvLen[i] = 1.0 / volSize.component(i);
    axisTexCoordSteps[i] = axisSteps[i] * axisInvLen[i];
  }

  Size nbEdges = 0;
  Size currEdges[10];//Use stack alloc to optimize memory cache; will never be more than 10
  Scalar currEdgePos[10][3];//Note: we use 3 scalars instead of Vec3 to avoid the many 'ifs' of the component methods
  Scalar currEdgeTexCoord[10][3];

  Boolean edgeMarks[12];
  for(i = 0; i < 12; ++i){
    edgeMarks[i] = false;
  }

  Size nextPointIndex = 0;
  Size currSlice = 0;
  Scalar currDepth = depthRange[1] - step*0.5;//back to front
  Size currPosIndex = 0;

  while(currSlice < nbSlices) {//Rely on slice instead of currDepth in case of important numerical imprecision
    while(true) {
      //Adjust currEdges if applicable:
      //  For each point that gets passed, add its next adjacent edges.

      Size nextPoint = pointDepthOrder[nextPointIndex];
      Scalar nextPointDepth = pointsDepth[nextPoint];
      if(nextPointDepth < currDepth)
        break;//No currEdges change

      Size insertPos = 0;
      for(i = 0; i < nbEdges; ++i) {
        Size edge = currEdges[i];
        for(j = 0; j < 3; ++j) {
          if(edges[edge][0] == nextPoint || edges[edge][1] == nextPoint) {
            insertPos = i;
            break;
          }
        }
      }

      Size nbEdgesToInsert = 0;
      Size edgesToInsert[3];
      for( i = 3; i--; ) { //CW order (backfacing)
        Size edge = pointCCWEdges[nextPoint][i];
        if(!edgeMarks[edge]) {
          edgeMarks[edge] = true;
          edgesToInsert[nbEdgesToInsert++] = edge;
        }
      }

      if(nbEdgesToInsert == 3) {
        nbEdges = 3;
      }
      else if(nbEdgesToInsert == 2) {//replace 1 by 2
        ++nbEdges;
        for( i = nbEdges; i-- > insertPos+2; ) {
          currEdges[i] = currEdges[i-1];
          currEdgePos[i] = currEdgePos[i-1];
          currEdgeDeltaPos[i] = currEdgeDeltaPos[i-1];
          currEdgeTexCoord[i] = currEdgeTexCoord[i-1];
          currEdgeDeltaTexCoord[i] = currEdgeDeltaTexCoord[i-1];
        }
      }
      else if(nbEdgesToInsert == 1) {//replace 2 by 1
        for( i = insertPos+2; i < nbEdges; ++i ) {
          currEdges[i-1] = currEdges[i];
          currEdgePos[i-1] = currEdgePos[i];
          currEdgeDeltaPos[i-1] = currEdgeDeltaPos[i];
          currEdgeTexCoord[i-1] = currEdgeTexCoord[i];
          currEdgeDeltaTexCoord[i-1] = currEdgeDeltaTexCoord[i];
        }
        --nbEdges;
      }
      else if(nbEdgesToInsert == 0)
        return;//should not happen unless big numerical imprecision issues

      for( i = 0; i<nbEdgesToInsert; ++i) {
        Size edge = edgesToInsert[i];
        Size index = i+insertPos;
        currEdges[index] = edge;

        currEdgePos[index][0] = points[nextPoint].x;
        currEdgePos[index][1] = points[nextPoint].y;
        currEdgePos[index][2] = points[nextPoint].z;
        currEdgeTexCoord[index][0] = texCoords[nextPoint].x;
        currEdgeTexCoord[index][1] = texCoords[nextPoint].y;
        currEdgeTexCoord[index][2] = texCoords[nextPoint].z;

        Size axisIndex = edgeAxis[edge];
        Scalar edgeStartDeltaStep = (nextPointDepth - currDepth) * invStep * axisSteps[axisIndex];
        currEdgePos[index][axisIndex] += edgeStartDeltaStep;
        currEdgeTexCoord[index][axisIndex] += edgeStartDeltaStep * axisInvLen[axisIndex];
      }
    }

    //Add triangle indices
    for(i = 2; i < nbEdges; ++i) {
      indices.push(currPosIndex);
      indices.push(currPosIndex+i-1);
      indices.push(currPosIndex+i);
    }

    //Add & increment positions & textures coordinates
    for(i = 0; i < nbEdges; ++i) {
      positions<currPosIndex> = Vec3(currEdgePos[i][0], currEdgePos[i][1], currEdgePos[i][2]);
      normals<currPosIndex> = Vec3(currEdgeTexCoord[i][0], currEdgeTexCoord[i][1], currEdgeTexCoord[i][2]);
      ++currPosIndex;

      Size axisIndex = edgeAxis[i];
      currEdgePos[i][axisIndex] += axisSteps[axisIndex];
      currEdgeTexCoord[i][axisIndex] += axisTexCoordSteps[axisIndex];
    }

    currDepth += step;
    ++currSlice;
  }
}
