//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

use Xfo;

operator generateVolumeSlices(
  io Vec3 volumeMin,
  io Vec3 volumeMax,
  io Size nbSlices,
  io Xfo volumeXfo,
  io Mat44 camera,
  io Mat44 projection,
  io Integer indices[],
  io Vec3 positions<>,
  io Vec3 normals<>
){
  indices.resize(0);

  if(nbSlices == 0)
    return;

  Vec3 volSize = volumeMax - volumeMin;
  if(volSize.x < PRECISION || volSize.y < PRECISION || volSize.z < PRECISION)
    return;

  report( "generateVolumeSlices\n" );
  report( "nbSlices: " + nbSlices + "\n" );
  report( "camera: " + camera + "\n");
  report( "projection: " + projection + "\n" );

  Mat44 volInv = volumeXfo.toMat44().inverse();
  Mat44 camInv = camera.inverse();
  Vec3 camPos = camInv.translation();
  report( "camPos " + camPos + "\n");

  Mat44 camProjInv = volInv * camInv * projection.inverse();
  Vec3 camRange[2];
  camRange[0] = camProjInv * Vec3(0.0, 0.0, -1.0);
  camRange[1] = camProjInv * Vec3(0.0, 0.0, 1.0);

  Vec3 camDir = (camRange[1] - camRange[0]);
  Scalar camDepth = camDir.length();
  camDir /= camDepth;
  Vec3 camYPos = camProjInv * Vec3(0.0, 0.5, -1.0);
  Vec3 biasedCamDir = ((camYPos - camRange[0]).unit() * 0.25 + camDir).unit();

  //Find the camera-aligned slice depth
  Vec3 volume[2];
  volume[0] = volumeMin;
  volume[1] = volumeMax;

  Vec3 camMinVolBBox[2];
  Size i, j, k;
  for(i = 0; i <3; ++i) {
    if(camDir.component(i) < 0) {
      camMinVolBBox[1].setComponent(i, volume[0].component(i));
      camMinVolBBox[0].setComponent(i, volume[1].component(i));
    }
    else {
      camMinVolBBox[0].setComponent(i, volume[0].component(i));
      camMinVolBBox[1].setComponent(i, volume[1].component(i));
    }
  }
  Scalar depthRange[2];
  for(i = 0; i <2; ++i) {
    depthRange[i] = (camMinVolBBox[i] - camRange[0]).dot(camDir);
    depthRange[i] = Math_clamp(depthRange[i], 0, camDepth);
  }
  Scalar depth = depthRange[1] - depthRange[0];
  Scalar relativePrecision = PRECISION * depthRange[1];

  if(abs(depth) < relativePrecision)
    return;

  Scalar step = depth / Scalar(nbSlices);
  Scalar invStep = 1.0 / step;

  report(" curr " + curr + " step " + step);

  Vec3 points[8], texCoords[8];
  Scalar pointsDepth[8];
  Size pointDepthOrder[8];
  Size index = 0;
  for(i = 0; i < 2; ++i) {
    for(j = 0; j < 2; ++j) {
      for(k = 0; k < 2; ++k) {
        points[index].set(volume[k].x, volume[j].y, volume[i].z);
        texCoords[index].set(Scalar(i), Scalar(j), Scalar(k));
        pointsDepth[index] = (points[index]-camRange[0]).dot(camDir);
        pointDepthOrder[index] = index;
        ++index;
      }
    }
  }

  //Sort points along cam inverse direction - back to front (simple bubble sort)
  for(i = 0; i < 8; ++i) {
    for(j = i+1; j < 8; ++j) {
      Size first = pointDepthOrder[i];
      Size second = pointDepthOrder[j];
      Scalar firstDepth = pointsDepth[first];
      Scalar secondDepth = pointsDepth[second];
      if(abs(firstDepth - secondDepth) < relativePrecision) {
        //Cam dir is axis-aligned; this is an exceptional case where we must ensure that coplanar 
        //points are sorted in coherent order (adjacency wise). A simple way to achieve this is to
        //sort according to a biased camDir:
        firstDepth = (points[first]-camRange[0]).dot(biasedCamDir);
        secondDepth = (points[first]-camRange[0]).dot(biasedCamDir);
      }
      if(pointsDepth[second] > pointsDepth[first]){
        pointDepthOrder[i] = second;
        pointDepthOrder[j] = first;
      }
    }
  }
  report "Order: " + pointDepthOrder;

  //constant cube topology
  Size edges[12][2];
  edges[0][0] = 0;edges[0][1] = 1;
  edges[1][0] = 1;edges[1][1] = 5;
  edges[2][0] = 5;edges[2][1] = 4;
  edges[3][0] = 4;edges[3][1] = 0;
  edges[4][0] = 0;edges[4][1] = 2;
  edges[5][0] = 1;edges[5][1] = 3;
  edges[6][0] = 5;edges[6][1] = 7;
  edges[7][0] = 4;edges[7][1] = 6;
  edges[8][0] = 2;edges[8][1] = 3;
  edges[9][0] = 3;edges[9][1] = 7;
  edges[10][0] = 7;edges[10][1] = 6;
  edges[11][0] = 6;edges[11][1] = 2;

  Size pointCCWEdges[8][3];
  pointCCWEdges[0][0] = 0;pointCCWEdges[0][1] = 4;pointCCWEdges[0][2] = 3;
  pointCCWEdges[1][0] = 0;pointCCWEdges[1][1] = 1;pointCCWEdges[1][2] = 2;
  pointCCWEdges[2][0] = 3;pointCCWEdges[2][1] = 8;pointCCWEdges[2][2] = 11;
  pointCCWEdges[3][0] = 5;pointCCWEdges[3][1] = 9;pointCCWEdges[3][2] = 8;
  pointCCWEdges[4][0] = 2;pointCCWEdges[4][1] = 7;pointCCWEdges[4][2] = 3;
  pointCCWEdges[5][0] = 6;pointCCWEdges[5][1] = 1;pointCCWEdges[5][2] = 2;
  pointCCWEdges[6][0] = 7;pointCCWEdges[6][1] = 11;pointCCWEdges[6][2] = 10;
  pointCCWEdges[7][0] = 6;pointCCWEdges[7][1] = 10;pointCCWEdges[7][2] = 9;

  Vec3 edgeDir[12];
  edgeDir[0] = edgeDir[8] = Vec3(1.0,0.0,0.0);
  edgeDir[1] = edgeDir[9] = Vec3(0.0,0.0,1.0);
  edgeDir[2] = edgeDir[10] = Vec3(-1.0,0.0,0.0);
  edgeDir[3] = edgeDir[11] = Vec3(0.0,0.0,-1.0);
  edgeDir[4] = edgeDir[5] = edgeDir[6] = edgeDir[7] = Vec3(0.0,1.0,0.0);

  Vec3 edgeInvLen[12];
  edgeInvLen[0] = edgeInvLen[8] = edgeInvLen[1] = edgeInvLen[9] = 1.0 / volSize.x;
  edgeInvLen[2] = edgeInvLen[10] = edgeInvLen[3] = edgeInvLen[11] = 1.0 / volSize.y;
  edgeInvLen[4] = edgeInvLen[5] = edgeInvLen[6] = edgeInvLen[7] = 1.0 / volSize.z;

  Scalar edgeSteps[12];
  Boolean edgeMarks[12];

  //Align edges with cam inverse direction
  for(i = 0; i < 12; ++i){
    Scalar dot = edgeDir[i].dot(camDir);
    if(dot > 0){
      edgeDir[i].negate();
    }
    else
      dot = -dot;

    if(dot > DIVIDEPRECISION)
      edgeSteps[i] = step / dot;
    //Else: don't care, perpendicular edges will never be sampled
    edgeMarks[i] = false;
  }

  Size nbEdges = 0;
  Size currEdges[10];//Use stack alloc to optimize memory cache; will never be more than 10
  Vec3 currEdgePos[10], currEdgeDeltaPos[10];
  Vec3 currEdgeTexCoord[10], currEdgeDeltaTexCoord[10];

  Size nextPointIndex = 0;
  Size currSlice = 0;
  Scalar currDepth = depthRange[1] - step*0.5;//back to front
  Size currPosIndex = 0;

  while(currSlice < nbSlices) {//Rely on slice instead of currDepth in case of important numerical imprecision
    while(true) {
      //Adjust currEdges if applicable:
      //  For each point that gets passed, add its next adjacent edges.

      Size nextPoint = pointDepthOrder[nextPointIndex];
      Scalar nextPointDepth = pointsDepth[nextPoint];
      if(nextPointDepth < currDepth)
        break;//No currEdges change

      Size insertPos = 0;
      for(i = 0; i < nbEdges; ++i) {
        Size edge = currEdges[i];
        for(j = 0; j < 3; ++j) {
          if(edges[edge][0] == nextPoint || edges[edge][1] == nextPoint) {
            insertPos = i;
            break;
          }
        }
      }

      Size nbEdgesToInsert = 0;
      Size edgesToInsert[3];
      for( i = 3; i--; ) { //CW order (backfacing)
        Size edge = pointCCWEdges[nextPoint][i];
        if(!edgeMarks[edge]) {
          edgeMarks[edge] = true;
          edgesToInsert[nbEdgesToInsert++] = edge;
        }
      }

      if(nbEdgesToInsert == 3) {
        nbEdges = 3;
      }
      else if(nbEdgesToInsert == 2) {//replace 1 by 2
        ++nbEdges;
        for( i = nbEdges; i-- > insertPos+2; ) {
          currEdges[i] = currEdges[i-1];
          currEdgePos[i] = currEdgePos[i-1];
          currEdgeDeltaPos[i] = currEdgeDeltaPos[i-1];
          currEdgeTexCoord[i] = currEdgeTexCoord[i-1];
          currEdgeDeltaTexCoord[i] = currEdgeDeltaTexCoord[i-1];
        }
      }
      else if(nbEdgesToInsert == 1) {//replace 2 by 1
        for( i = insertPos+2; i < nbEdges; ++i ) {
          currEdges[i-1] = currEdges[i];
          currEdgePos[i-1] = currEdgePos[i];
          currEdgeDeltaPos[i-1] = currEdgeDeltaPos[i];
          currEdgeTexCoord[i-1] = currEdgeTexCoord[i];
          currEdgeDeltaTexCoord[i-1] = currEdgeDeltaTexCoord[i];
        }
        --nbEdges;
      }
      else if(nbEdgesToInsert == 0)
        return;//should not happen unless big numerical imprecision issues

      for( i = 0; i<nbEdgesToInsert; ++i) {
        Size edge = edgesToInsert[i];
        Size index = i+insertPos;
        Scalar edgeStep = edgeSteps[edge];
        currEdges[index] = edge;
        Vec3 edgeStartVec = ((nextPointDepth - currDepth) * invStep * edgeStep) * edgeDir[edge];
        currEdgePos[index] = points[nextPoint] + edgeStartVec;
        currEdgeDeltaPos[index] = edgeStep*edgeDir[edge];
        currEdgeTexCoord[index] = texCoords[nextPoint] + edgeInvLen[edge]*edgeStartVec;
        currEdgeDeltaTexCoord[index] = (edgeStep*edgeInvLen[edge])*edgeDir[edge];
      }
    }

    //Add triangle indices
    for(i = 2; i < nbEdges; ++i) {
      indices.push(currPosIndex);
      indices.push(currPosIndex+i-1);
      indices.push(currPosIndex+i);
    }

    //Add & increment positions & textures coordinates
    for(i = 0; i < nbEdges; ++i) {
      positions<currPosIndex> = currEdgePos[i];
      normals<currPosIndex> = currEdgeTexCoord[i];
      ++currPosIndex;

      currEdgePos[i] += currEdgeDeltaPos[i];
      currEdgeTexCoord[i] += currEdgeDeltaTexCoord[i];
    }

    currDepth += step;
    ++currSlice;
  }
}
