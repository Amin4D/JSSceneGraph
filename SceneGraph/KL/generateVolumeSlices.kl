//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

use Xfo;

operator generateVolumeSlices(
  io Vec3 volumeMin,
  io Vec3 volumeMax,
  io Size nbSlices,
  io Xfo volumeXfo,
  io Mat44 camera,
  io Mat44 projection,
  io Integer indices[],
  io Vec3 positions<>,
  io Vec3 normals<>
){
  indices.resize(0);

  if(projection.row3.z == 0.0) {
    report "Todo: support orthogaphic projections";
    return;
  }

  if(nbSlices == 0)
    return;

  Vec3 volSize = volumeMax - volumeMin;
  if(volSize.x < PRECISION || volSize.y < PRECISION || volSize.z < PRECISION)
    return;

  Vec3 invVolSize = volSize.inverse();

  Mat44 volInv = volumeXfo.toMat44().inverse();
  Mat44 camInv = camera.inverse();
  Vec3 camPos = camInv.translation();

  Mat44 camProjInv = volInv * camInv * projection.inverse();
  Vec3 camRange[2];
  camRange[0] = camProjInv * Vec3(0.0, 0.0, -1.0);
  camRange[1] = camProjInv * Vec3(0.0, 0.0, 1.0);

  Vec3 camDir = (camRange[1] - camRange[0]);
  Scalar camDepth = camDir.length();
  camDir /= camDepth;
  Vec3 camYPos = camProjInv * Vec3(0.5, 0.5, -1.0);
  Vec3 biasedCamDir = ((camYPos - camRange[0]).unit() * 0.25 + camDir).unit();

  //Find the camera-aligned slice depth
  Vec3 volume[2];
  volume[0] = volumeMin;
  volume[1] = volumeMax;

  Vec3 camVolBBox[2];
  Size i, j, k;
  for(i = 0; i <3; ++i) {
    if(camDir.component(i) < 0) {
      camVolBBox[1].setComponent(i, volume[0].component(i));
      camVolBBox[0].setComponent(i, volume[1].component(i));
    }
    else {
      camVolBBox[0].setComponent(i, volume[0].component(i));
      camVolBBox[1].setComponent(i, volume[1].component(i));
    }
  }
  Scalar depthRange[2];
  for(i = 0; i <2; ++i) {
    depthRange[i] = (camVolBBox[i] - camRange[0]).dot(camDir);
    depthRange[i] = Math_clamp(depthRange[i], 0, camDepth);
  }
  Scalar depth = depthRange[1] - depthRange[0];
  Scalar relativePrecision = PRECISION * depthRange[1];

  if(abs(depth) < relativePrecision)
    return;

  Scalar step = depth / Scalar(nbSlices);
  Scalar invStep = 1.0 / step;

  Vec3 points[8], texCoords[8];
  Scalar pointsDepth[8];
  Size pointDepthOrder[8];
  Size index = 0;
  for(i = 0; i < 2; ++i) {
    for(j = 0; j < 2; ++j) {
      for(k = 0; k < 2; ++k) {
        points[index].set(volume[k].x, volume[j].y, volume[i].z);
        texCoords[index].set(Scalar(i), Scalar(j), Scalar(k));
        pointsDepth[index] = (points[index]-camRange[0]).dot(camDir);
        pointDepthOrder[index] = index;
        ++index;
      }
    }
  }

  //Sort points along cam inverse direction - back to front (simple bubble sort)
  for(i = 0; i < 8; ++i) {
    for(j = i+1; j < 8; ++j) {
      Size first = pointDepthOrder[i];
      Size second = pointDepthOrder[j];
      Scalar firstDepth = pointsDepth[first];
      Scalar secondDepth = pointsDepth[second];
      if(abs(firstDepth - secondDepth) < relativePrecision) {
        //Cam dir is axis-aligned; this is an exceptional case where we must ensure that coplanar 
        //points are sorted in coherent order (adjacency wise). A simple way to achieve this is to
        //sort according to a biased camDir:
        firstDepth = (points[first]-camRange[0]).dot(biasedCamDir);
        secondDepth = (points[second]-camRange[0]).dot(biasedCamDir);
      }
      if(secondDepth > firstDepth){
        pointDepthOrder[i] = second;
        pointDepthOrder[j] = first;
      }
    }
  }
  //constant cube topology
  Size edgePoints[12][2];
  edgePoints[0][0] = 0;edgePoints[0][1] = 1;
  edgePoints[1][0] = 1;edgePoints[1][1] = 5;
  edgePoints[2][0] = 5;edgePoints[2][1] = 4;
  edgePoints[3][0] = 4;edgePoints[3][1] = 0;
  edgePoints[4][0] = 0;edgePoints[4][1] = 2;
  edgePoints[5][0] = 1;edgePoints[5][1] = 3;
  edgePoints[6][0] = 5;edgePoints[6][1] = 7;
  edgePoints[7][0] = 4;edgePoints[7][1] = 6;
  edgePoints[8][0] = 2;edgePoints[8][1] = 3;
  edgePoints[9][0] = 3;edgePoints[9][1] = 7;
  edgePoints[10][0] = 7;edgePoints[10][1] = 6;
  edgePoints[11][0] = 6;edgePoints[11][1] = 2;

  Size pointCCWEdges[8][3];
  pointCCWEdges[0][0] = 0;pointCCWEdges[0][1] = 4;pointCCWEdges[0][2] = 3;
  pointCCWEdges[1][0] = 0;pointCCWEdges[1][1] = 1;pointCCWEdges[1][2] = 5;
  pointCCWEdges[2][0] = 4;pointCCWEdges[2][1] = 8;pointCCWEdges[2][2] = 11;
  pointCCWEdges[3][0] = 5;pointCCWEdges[3][1] = 9;pointCCWEdges[3][2] = 8;
  pointCCWEdges[4][0] = 3;pointCCWEdges[4][1] = 7;pointCCWEdges[4][2] = 2;
  pointCCWEdges[5][0] = 6;pointCCWEdges[5][1] = 1;pointCCWEdges[5][2] = 2;
  pointCCWEdges[6][0] = 7;pointCCWEdges[6][1] = 11;pointCCWEdges[6][2] = 10;
  pointCCWEdges[7][0] = 6;pointCCWEdges[7][1] = 10;pointCCWEdges[7][2] = 9;

  Size edgeAxis[12];
  edgeAxis[0] = edgeAxis[8] = edgeAxis[2] = edgeAxis[10] = 0;
  edgeAxis[4] = edgeAxis[5] = edgeAxis[6] = edgeAxis[7] = 1;
  edgeAxis[1] = edgeAxis[9] = edgeAxis[3] = edgeAxis[11] = 2;

  Scalar axisSteps[3];
  Scalar axisTexCoordSteps[3];
  Scalar axisInvLen[3];

  for(i = 0; i < 3; ++i){
    Scalar dot = camDir.component(i);
    if(abs(dot) > DIVIDEPRECISION)
      axisSteps[i] = step / dot;
    else
      axisSteps[i] = 1;//in fact we won't use it...
    axisInvLen[i] = 1.0 / volSize.component(i);
    axisTexCoordSteps[i] = axisSteps[i] * axisInvLen[i];
  }

  Size nbEdges = 0;
  Size currEdges[10];//Use stack alloc to optimize memory cache; will never be more than 10
  Scalar currEdgePos[10][3];//Note: we use 3 scalars instead of Vec3 to avoid the many 'ifs' of the component methods
  Scalar currEdgeTexCoord[10][3];

  Boolean edgeMarks[12];
  for(i = 0; i < 12; ++i){
    edgeMarks[i] = false;
  }

  Size nextPointIndex = 0;
  Size currSlice = 0;
  Scalar currDepth = depthRange[1] - step*0.5;//back to front
  Integer currPosIndex = 0;

  while(currSlice < nbSlices) {//Rely on slice instead of currDepth in case of important numerical imprecision
    while(true) {
      //Adjust currEdges if applicable:
      //  For each point that gets passed, add its next adjacent edges.

      Size nextPoint = pointDepthOrder[nextPointIndex];
      Scalar nextPointDepth = pointsDepth[nextPoint];
      if(nextPointDepth < currDepth)
        break;//No currEdges change

      ++nextPointIndex;

      Size insertPos = 0;
      for(i = 0; i < nbEdges; ++i) {
        Size edge = currEdges[i];
        if(edgePoints[edge][0] == nextPoint || edgePoints[edge][1] == nextPoint) {
          insertPos = i;
          if(insertPos != 0)
            break;//Else: the first edge of the set of 2 edges might be at the end!!!
        }
      }

      Size nbEdgesToInsert = 0;
      Size lastMarkedEdgePointOrder;
      Size edgesToInsert[3];
      for( i = 3; i--; ) { //CW order (backfacing)
        Size edge = pointCCWEdges[nextPoint][i];
        if(edgeMarks[edge]) {
          lastMarkedEdgePointOrder = i;
        }
        else {
          edgeMarks[edge] = true;
          edgesToInsert[nbEdgesToInsert++] = edge;
        }
      }
      if(nbEdgesToInsert == 3) {
        nbEdges = 3;
      }
      else if(nbEdgesToInsert == 2) {//replace 1 by 2
        if(lastMarkedEdgePointOrder == 1) {//flipped around: inverse order
          Size tmp = edgesToInsert[0];
          edgesToInsert[0] = edgesToInsert[1];
          edgesToInsert[1] = tmp;
        }
        ++nbEdges;
        for( i = nbEdges; i-- > insertPos+2; ) {
          currEdges[i] = currEdges[i-1];
          currEdgePos[i] = currEdgePos[i-1];
          currEdgeTexCoord[i] = currEdgeTexCoord[i-1];
        }
      }
      else if(nbEdgesToInsert == 1) {//replace 2 by 1
        if(insertPos == nbEdges-1) {
          //Special case: the could be a wrap around (edges to remove are 0 and N-1; not index-wise consecutive)
          insertPos = 0;
        }
        else {
          for( i = insertPos+2; i < nbEdges; ++i ) {
            currEdges[i-1] = currEdges[i];
            currEdgePos[i-1] = currEdgePos[i];
            currEdgeTexCoord[i-1] = currEdgeTexCoord[i];
          }
        }
        --nbEdges;
      }
      else if(nbEdgesToInsert == 0)
        return;//should not happen unless big numerical imprecision issues

      for( i = 0; i<nbEdgesToInsert; ++i) {
        Size edge = edgesToInsert[i];
        j = i+insertPos;
        currEdges[j] = edge;

        currEdgePos[j][0] = points[nextPoint].x;
        currEdgePos[j][1] = points[nextPoint].y;
        currEdgePos[j][2] = points[nextPoint].z;
        currEdgeTexCoord[j][0] = texCoords[nextPoint].x;
        currEdgeTexCoord[j][1] = texCoords[nextPoint].y;
        currEdgeTexCoord[j][2] = texCoords[nextPoint].z;
        Size axisIndex = edgeAxis[edge];
        Scalar edgeStartDeltaStep = (currDepth - nextPointDepth) * invStep * axisSteps[axisIndex];
        currEdgePos[j][axisIndex] += edgeStartDeltaStep;
        currEdgeTexCoord[j][axisIndex] += edgeStartDeltaStep * axisInvLen[axisIndex];
      }
    }

    //Add triangle indices
    for(i = 2; i < nbEdges; ++i) {
      indices.push(currPosIndex);
      indices.push(currPosIndex+i);
      indices.push(currPosIndex+i-1);
    }

    //Add & increment positions & textures coordinates
    for(i = 0; i < nbEdges; ++i) {
      positions[currPosIndex] = Vec3(currEdgePos[i][0], currEdgePos[i][1], currEdgePos[i][2]);
      normals[currPosIndex] = Vec3(currEdgeTexCoord[i][0], currEdgeTexCoord[i][1], currEdgeTexCoord[i][2]);
      ++currPosIndex;
      Size axisIndex = edgeAxis[currEdges[i]];
      currEdgePos[i][axisIndex] -= axisSteps[axisIndex];
      currEdgeTexCoord[i][axisIndex] -= axisTexCoordSteps[axisIndex];
    }

    currDepth -= step;
    ++currSlice;
  }
}
