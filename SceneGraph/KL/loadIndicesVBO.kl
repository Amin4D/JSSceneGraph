//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

use OGLBuffer, OGLShaderProgram;

operator loadIndicesVBO(
  io OGLShaderProgram shaderProgram,
  io Integer bufferData[],
  io OGLIndicesBuffer buffer
) {
//  report("genVBO  " + buffer.name + ":" + buffer.bufferID +" elementCount:" + buffer.elementCount );
  switch(shaderProgram.drawMode){
    case GL_TRIANGLES_ADJACENCY:
      Integer triAdjBufferData[];
      triAdjBufferData.resize(bufferData.size()*2);
      Integer id0, id1, id2, id3, id4, id5;
      Integer ids[6];
      for(Integer i=0; i<bufferData.size(); i+=3){
        
        ids[0] = bufferData[i+0];
        ids[1] = bufferData[i+1];
        ids[2] = bufferData[i+2];
        
        for(Integer j=0; j<3; j++){
          Integer unmatchedId = -1;
          Integer eid0 = ids[j];
          Integer eid1 = ids[(j+1)%3];
          for(Integer k=0; k<bufferData.size() && unmatchedId>=0; k+=3){
           
            if(i!=k){
              for(Integer l=0; l<3 && unmatchedId>=0; l++){
                if(eid0 == bufferData[(k+l+0)%3] &&
                   eid1 == bufferData[(k+l+1)%3]){
                  unmatchedId = bufferData[(j+2)%3];
                }
              }
            }
          }
          if(unmatchedId>=0){
            ids[3+j] = unmatchedId;
          }
        }
        triAdjBufferData[(i+0)*2] = ids[0];
        triAdjBufferData[(i+1)*2] = ids[3];
        triAdjBufferData[(i+1)*2] = ids[1];
        triAdjBufferData[(i+2)*2] = ids[4];
        triAdjBufferData[(i+2)*2] = ids[2];
        triAdjBufferData[(i+2)*2] = ids[5];
      }
      buffer.genBuffer(triAdjBufferData.data(), triAdjBufferData.dataSize(), triAdjBufferData.size());
      
    default :
      buffer.genBuffer(bufferData.data(), bufferData.dataSize(), bufferData.size());
  }

}

