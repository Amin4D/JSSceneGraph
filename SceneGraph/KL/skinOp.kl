//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

use Vec3;
use Vec4;
use Mat44;
use Xfo;

operator skinOp
(
  in Size index,
  io Vec3 positions<>,
  io Vec3 normals<>,/*
  io Vec4 tangents<>,*/
  
  io Mat44 skinningMatrices[],
  io Vec4 boneIds<>,
  io Vec4 skinWeights<>,
  io Integer boneMapping[],
  
  io Vec3 deformed_position,
  io Vec3 deformed_normal,/*
  io Vec4 deformed_tangent*/
) {
  // sanity check
  if (boneIds.size() != skinWeights.size())
    return;
    
//  report("skinOp<<<");
  
  Vec3 position = positions[index];
  Vec3 normal = normals[index];
//  Vec4 tangent = tangents[index];

  // add the normal to the position
  normal += position;
//  var Vec3 tangent3(tangent.x, tangent.y, tangent.z);
//  tangent3 += position;

  var Vec3 resultPos(0.0, 0.0, 0.0);
  var Vec3 resultNormal(0.0, 0.0, 0.0);
//  var Vec3 resultTangent(0.0, 0.0, 0.0);
  
  

  for (var Integer i = 0; i < 4; i++) {
    // the bindPose is already inversed
    Scalar weight = skinWeights[index].getElem(i);
    if (weight > 0.001) {
      Integer id = Integer(boneIds[index].getElem(i));
      resultPos += (position * skinningMatrices[id]) * weight;
      resultNormal += (normal * skinningMatrices[id]) * weight;
   //   resultTangent += (tangent3 * skinningMatrices[id]) * weight;
    }
  }

  // take care of the bindMatrix
  deformed_position = resultPos;
  deformed_normal = resultNormal;
  deformed_normal -= deformed_position;
  /*
  tangent3 = resultTangent * bindMatrix;
  tangent3 -= position;
  deformed_tangent.x = tangent3.x;
  deformed_tangent.y = tangent3.y;
  deformed_tangent.z = tangent3.z;
  deformed_tangent.t = tangent.t;
  */
//  report("skinOp>>>");
}