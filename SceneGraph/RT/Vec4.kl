
//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

use Math;

function Vec4(Scalar x, Scalar y, Scalar z, Scalar t) {
  this.x = x;
  this.y = y;
  this.z = z;
  this.t = t;
}

function Vec4.set(Scalar x, Scalar y, Scalar z, Scalar t) {
  this.x = x;
  this.y = y;
  this.z = z;
  this.t = t;
}

function Vec4.setNull() {
  this.x = this.y = this.z = this.t = 0.0;
}

function Boolean Vec4.equal (in Vec4 other) {
  return this.x == other.x && this.y == other.y && this.z == other.z && this.t == other.t;
}

function Boolean Vec4.almostEqual(in Vec4 other, in Scalar precision) {
  return
      (abs(this.x - other.x) < precision) &&
      (abs(this.y - other.y) < precision) &&
      (abs(this.z - other.z) < precision) &&
      (abs(this.t - other.t) < precision);
}

function Boolean Vec4.almostEqual(in Vec4 other) {
  return this.almostEqual(other, PRECISION);
}

function Vec4 + (Vec4 a, Vec4 b) {
  return Vec4(a.x + b.x, a.y + b.y, a.z + b.z, a.t + b.t);
}

function Vec4. += (Vec4 other) {
  this = this + other;
}

function Vec4 - (Vec4 a, Vec4 b) {
  return Vec4(a.x - b.x, a.y - b.y, a.z - b.z, a.t - b.t);
}

function Vec4. -= (Vec4 other) {
  this = this - other;
}

function Vec4 * (Scalar a, Vec4 b) {
  return Vec4(a * b.x, a * b.y, a * b.z, a * b.t);
}

function Vec4 * (Vec4 a, Scalar b) {
  return Vec4(a.x * b, a.y * b, a.z * b, a.t * b);
}

function Vec4 * (Vec4 a, Vec4 b) {
  return Vec4(a.x * b.x, a.y * b.y, a.z * b.z, a.t * b.t);
}

function Vec4. *= (Scalar other) {
  this = this * other;
}

function Vec4. *= (Vec4 other) {
  this = this * other;
}

function Vec4 / (Vec4 a, Vec4 b) {
  return Vec4(a.x / b.x, a.y / b.y, a.z / b.z, a.t / b.t);
}

function Vec4 / (Vec4 a, Scalar b) {
  return Vec4(a.x / b, a.y / b, a.z / b, a.t / b);
}

function Vec4. /= (Scalar other) {
  this = this / other;
}

function Vec4. /= (Vec4 other) {
  this = this / other;
}

function Vec4 Vec4.negate() {
  return Vec4(-this.x, - this.y, - this.z, - this.t);
}

function Scalar Vec4.dot(in Vec4 other) {
  return this.x * other.x + this.y * other.y + this.z * other.z + this.t * other.t;
}

function Scalar Vec4.lengthSquared() {
  return this.dot(this);
}

function Scalar Vec4.length() {
  return sqrt(this.lengthSquared());
}

function Vec4 Vec4.unit() {
  Scalar n = this.length();
  if (n > DIVIDEPRECISION)
    return this / n;
  return this;
}

//TODO: uncomment the return value when compilation issue is fixed
function /*Scalar*/ Vec4.setUnit() {
  Scalar n = this.length();
  if (n > DIVIDEPRECISION)
    this /= n;
  //return n;
}

//expects that both vectors are unit
function Scalar Vec4.unitsGetAngleTo(in Vec4 other) {
  return acos(this.dot(other));
}

function Vec4 Vec4.lerp(in Vec4 other, in Scalar t) {
  return this + ((other - this) * t);
}
