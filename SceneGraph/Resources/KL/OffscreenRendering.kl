
//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

#include 'FABRIC_ROOT/SceneGraph/Resources/KL/loadShader.kl'

operator prepareOffscreenRendering(
  io Integer width,
  io Integer height,
  io Integer osFBO,
  io Integer osPrevFBO,
  io Integer osColorID,
  io Integer osDepthID
) {
  // report(">>>prepareOffscreenRendering");
  glGetIntegerv(GL_FRAMEBUFFER_BINDING_EXT, osPrevFBO.data());

  glEnable(GL_TEXTURE_2D);

  if (osFBO > 0) {
    var Integer texWidth, texHeight;

    // Have the dimensions changed?
    glBindTexture(GL_TEXTURE_2D, osColorID);
    glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_WIDTH, texWidth.data());
    glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_HEIGHT, texHeight.data());

    if (width != texWidth || height != texHeight) {
      // Textures need to be deleted first.
      glDeleteTextures(1, osColorID.data());
      glDeleteTextures(1, osDepthID.data());

      glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
      glDeleteFramebuffersEXT(1, osFBO.data());

      osFBO = osColorID = osDepthID = 0;
    }
  }

  if (osFBO == 0) {
    var Data NULL;

    glGenTextures(1, osColorID.data());
    glBindTexture(GL_TEXTURE_2D, osColorID);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    //NULL means reserve texture memory, but texels are undefined
    // ==> GL_RGBA32F_ARB
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F_ARB/* GL_RGBA8 */, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);

    // Try to use a texture depth component
    glGenTextures(1, osDepthID.data());
    glBindTexture(GL_TEXTURE_2D, osDepthID);

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

    glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, width, height, 0, GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE, NULL);

    // create a framebuffer object
    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
    glGenFramebuffersEXT(1, osFBO.data());
    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, osFBO);

    // attach the texture to FBO depth attachment point
    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, osColorID, 0);
    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_TEXTURE_2D, osDepthID, 0);

    // check FBO status
    var Integer status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
    if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
      report('prepareOffscreenRendering: GL_FRAMEBUFFER_COMPLETE_EXT failed, CANNOT use FBO\n');

      glDeleteFramebuffersEXT(1, osFBO.data());
      osFBO = - 1;
    }
  }

  // Switch to off-screen rendering using our FBO
  if (osFBO > 0) {
    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, osFBO);
  }
  // report("<<<prepareOffscreenRendering");
}

operator renderOffscreenToView(
  io Integer width,
  io Integer height,
  io Integer osPrevFBO,
  io Integer osColorID,
  io Integer program
) {
  // report(">>>renderOffscreenToView");

  glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, osPrevFBO);

  glPushAttrib(GL_DEPTH_BUFFER_BIT | GL_VIEWPORT_BIT | GL_TEXTURE_BIT);

  glViewport(0, 0, width, height);
  glDisable(GL_DEPTH_TEST);

  glClearColor(0.0, 1.0, 0.0, 1.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  glUseProgram(program);

  var Integer posLocation = glGetAttribLocation(program, 'a_position');
  var Integer texLocation = glGetAttribLocation(program, 'a_texCoord');
  var Integer smpLocation = glGetUniformLocation(program, 'u_rgbaImage');

  // Set the sampler
  glEnable(GL_TEXTURE_2D);
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, osColorID);
  glUniform1i(smpLocation, 0);

  // Draw a quad in the upper left with debugging info
  var Vec3 p[4];
  p[0] = Vec3(-1.0, 1.0, 0.0);
  p[1] = Vec3(1.0, 1.0, 0.0);
  p[2] = Vec3(1.0, - 1.0, 0.0);
  p[3] = Vec3(-1.0, - 1.0, 0.0);
  var Vec2 t[4];
  t[0] = Vec2(0.0, 1.0);
  t[1] = Vec2(1.0, 1.0);
  t[2] = Vec2(1.0, 0.0);
  t[3] = Vec2(0.0, 0.0);
  var Integer idx[6];
  idx[0] = 0; idx[1] = 2; idx[2] = 1;
  idx[3] = 0; idx[4] = 3; idx[5] = 2;

  var Integer bufferID[3];

  var Data NULL;

  glGenBuffers(3, bufferID.data());

  glBindBuffer(GL_ARRAY_BUFFER, bufferID[0]);
  glBufferData(GL_ARRAY_BUFFER, p.dataSize(), p.data(), GL_STATIC_DRAW);
  glEnableVertexAttribArray(posLocation);
  glVertexAttribPointer(posLocation, 3, GL_FLOAT, GL_FALSE, 0, NULL);

  glBindBuffer(GL_ARRAY_BUFFER, bufferID[1]);
  glBufferData(GL_ARRAY_BUFFER, t.dataSize(), t.data(), GL_STATIC_DRAW);
  glEnableVertexAttribArray(texLocation);
  glVertexAttribPointer(texLocation, 2, GL_FLOAT, GL_FALSE, 0, NULL);

  glBindBuffer(GL_ARRAY_BUFFER, bufferID[2]);
  glBufferData(GL_ARRAY_BUFFER, idx.dataSize(), idx.data(), GL_STATIC_DRAW);
  glBindBuffer(GL_ARRAY_BUFFER, 0);

  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, bufferID[2]);
  glDrawElements(GL_TRIANGLES, idx.size(), GL_UNSIGNED_INT, NULL);
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

  glFinish();

  glBindTexture(GL_TEXTURE_2D, 0);

  glDeleteBuffers(3, bufferID.data());

  glPopAttrib();

  // report("<<<renderOffscreenToView");
}

operator renderTextureToView(
  io Integer textureUnit,
  io Integer program
) {
  // report(">>>renderTextureToView");

  if (!program) {
    ShaderSource pixelShader;
    ShaderSource fragmentShader;
    pixelShader.type = GL_VERTEX_SHADER;
    pixelShader.code = '\
      attribute vec4 a_position; \
      attribute vec4 a_texCoord; \
      void main() { \
        gl_TexCoord[0].st = a_texCoord.xy; \
        gl_Position = a_position; \
      }';

    fragmentShader.type = GL_FRAGMENT_SHADER;
    fragmentShader.code = '\
      uniform sampler2D u_rgbaImage; \
      void main() \
      { \
        gl_FragColor = texture2D( u_rgbaImage, gl_TexCoord[0].st ); \
      }';
    ShaderSource shaders[];
    shaders.push(pixelShader);
    shaders.push(fragmentShader);
    ShaderProgramParam programParams[];
    program = fglCreateProgramFromShaders('renderTextureToView', shaders, programParams);
    if (!program) {
      report('Error in renderTextureToView');
      return;
    }
  }

  glUseProgram(program);

  var Integer posLocation = glGetAttribLocation(program, 'a_position');
  var Integer texLocation = glGetAttribLocation(program, 'a_texCoord');
  var Integer smpLocation = glGetUniformLocation(program, 'u_rgbaImage');

  // Set the sampler
  glEnable(GL_TEXTURE_2D);
  glDisable(GL_DEPTH_TEST);
  glDisable(GL_CULL_FACE);

  glUniform1i(smpLocation, textureUnit);

  // Draw a quad in the upper left with debugging info
  var Vec3 p[4];
  p[0] = Vec3(-1.0, 1.0, 0.0);
  p[1] = Vec3(1.0, 1.0, 0.0);
  p[2] = Vec3(1.0, - 1.0, 0.0);
  p[3] = Vec3(-1.0, - 1.0, 0.0);
  var Vec2 t[4];
  t[0] = Vec2(0.0, 0.0);
  t[1] = Vec2(1.0, 0.0);
  t[2] = Vec2(1.0, 1.0);
  t[3] = Vec2(0.0, 1.0);
  var Integer idx[6];
  idx[0] = 0; idx[1] = 2; idx[2] = 1;
  idx[3] = 0; idx[4] = 3; idx[5] = 2;

  var Integer bufferID[3];

  var Data NULL;

  glGenBuffers(3, bufferID.data());

  glBindBuffer(GL_ARRAY_BUFFER, bufferID[0]);
  glBufferData(GL_ARRAY_BUFFER, p.dataSize(), p.data(), GL_STATIC_DRAW);
  glEnableVertexAttribArray(posLocation);
  glVertexAttribPointer(posLocation, 3, GL_FLOAT, GL_FALSE, 0, NULL);

  glBindBuffer(GL_ARRAY_BUFFER, bufferID[1]);
  glBufferData(GL_ARRAY_BUFFER, t.dataSize(), t.data(), GL_STATIC_DRAW);
  glEnableVertexAttribArray(texLocation);
  glVertexAttribPointer(texLocation, 2, GL_FLOAT, GL_FALSE, 0, NULL);

  glBindBuffer(GL_ARRAY_BUFFER, bufferID[2]);
  glBufferData(GL_ARRAY_BUFFER, idx.dataSize(), idx.data(), GL_STATIC_DRAW);
  glBindBuffer(GL_ARRAY_BUFFER, 0);

  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, bufferID[2]);
  glDrawElements(GL_TRIANGLES, idx.size(), GL_UNSIGNED_INT, NULL);
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

  glEnable(GL_DEPTH_TEST);
  glEnable(GL_CULL_FACE);
  // report("<<<renderTextureToView");
}