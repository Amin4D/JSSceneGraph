
//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

function Integer fglCreateAndCompileShader(String shaderName, Integer type, String src) {
  var Integer shaderID = glCreateShader(type);
  if (shaderID == 0) {
    report(shaderName + ' : glCreateShader failed');
    return 0;
  }

  // Load and compile the shader source
  var Integer strlens[];
  var String srcs[];
  strlens.push(Integer(src.length()));
  srcs.push(src);
  glShaderSource(shaderID, 1, srcs, strlens);
  glCompileShader(shaderID);

  // Check the compile status
  var Integer compiled[];
  glGetShaderiv(shaderID, GL_COMPILE_STATUS, compiled);
  if (compiled.size() == 0 || compiled[0] == 0)
    report(shaderName + ' : Shader compilation failed:');

  var Integer infoLen[];
  glGetShaderiv(shaderID, GL_INFO_LOG_LENGTH, infoLen);

  if (infoLen.size() == 1 && infoLen[0] > 1) {
    if (compiled.size() > 0 && compiled[0] > 0) {
      report(shaderName + ' : Shader compilation succeeded with warnings:');
    }
    var String infoLog;
    var Size bufferSize[];
    var Size bufferTotalSize = 0;
    for(var Size i=0;i<infoLen.size();i++)
    {
      bufferSize.push(Size(infoLen[i]));
      bufferTotalSize += bufferSize[i];
    }
      
    glGetShaderInfoLog(shaderID, bufferTotalSize, bufferSize, infoLog);
    report(infoLog);
  }
  else if (!compiled) {
    report('<Unknown reason>');
  }

  if (!compiled) {
    glDeleteShader(shaderID);
    return 0;
  }

  return shaderID;
}

function Integer fglCreateProgramFromShaders(
  String shaderName,
  ShaderSource shaders[],
  ShaderProgramParam programParams[]
) {
  if (shaders.size() == 0) {
    report(shaderName + ' : No shaders given to build a program from.');
    return 0;
  }

  var Integer shaderIDs[];
  for (var Size i = 0; i < shaders.size(); i++) {
    var Integer shaderID = fglCreateAndCompileShader(shaderName, shaders[i].type, shaders[i].code);
    if (shaderID == 0)
      break;
    shaderIDs.push(shaderID);
  }

  var Integer programID = 0;
  if (shaderIDs.size() == shaders.size()) {
    programID = glCreateProgram();
    if (programID) {
      for (var Size i = 0; i < shaderIDs.size(); i++) {
        glAttachShader(programID, shaderIDs[i]);
      }
      // The program parameters need to be added before linking
      for (var Size i = 0; i < programParams.size(); i++) {
        glProgramParameteriEXT(programID, programParams[i].id, programParams[i].value);
      }

      glLinkProgram(programID);

      var Integer linked[];
      glGetProgramiv(programID, GL_LINK_STATUS, linked);
      if (linked.size() == 0 || linked[0] == 0) {
        report(shaderName + ' : Program linking failed:');
      }

      var Integer infoLen[];
      glGetProgramiv(programID, GL_INFO_LOG_LENGTH, infoLen);

      if (infoLen.size() > 0 && infoLen[0] > 1) {
        if (linked.size() > 0 || linked[0] > 0) {
          report(shaderName + ' : Program linking succeeded, with warnings:');
        }
        var Size bufferSize[];
        var Size bufferTotalSize = 0;
        for(var Size i=0;i<infoLen.size();i++)
        {
          bufferSize.push(Size(infoLen[i]));
          bufferTotalSize += bufferSize[i];
        }

        var String infoLog;
        glGetProgramInfoLog(programID, bufferTotalSize, bufferSize, infoLog);
        report(infoLog);
      }
      else if (!linked) {
        report('<Unknown reason>');
      }

      if (!linked) {
        glDeleteProgram(programID);
        programID = 0;
      }
    }
  }
  for (var Size i = 0; i < shaderIDs.size(); i++) {
    glDeleteShader(shaderIDs[i]);
  }
  return programID;
}

function String getRTTypeFromOGLType(in Integer oglType) {
  if (oglType == GL_FLOAT)
    return 'Scalar';
  else if (oglType == GL_FLOAT_VEC2)
    return 'Vec2';
  else if (oglType == GL_FLOAT_VEC3)
    return 'Vec3';
  else if (oglType == GL_FLOAT_VEC4)
    return 'Color';
  else if (oglType == GL_INT)
    return 'Integer';
  else if (oglType == GL_BOOL)
    return 'Boolean';
  else if (oglType == GL_FLOAT_MAT3)
    return 'Mat33';
  else if (oglType == GL_FLOAT_MAT4)
    return 'Mat44';

  return '';
}

operator validateShaderBindings(
  io String shaderName,
  io Integer program,
  io ShaderValue uniformValues[],
  io ShaderValue attributeValues[],
) {
  var String name, typeName;
  var Integer i, j, size[];
  var Size type[];

  for (i = 0; i < uniformValues.size(); i++) {
    uniformValues[i].location = glGetUniformLocation(program, uniformValues[i].name);
    if (uniformValues[i].location == - 1) {
      report('ERROR: ' + shaderName + ': Attribute does not exist in the shader code: ' + uniformValues[i].name);
    }
  }

  for (i = 0; i < attributeValues.size(); i++) {
    attributeValues[i].location = glGetAttribLocation(program, attributeValues[i].name);
    if (attributeValues[i].location == - 1) {
      report('ERROR: ' + shaderName + ': Attribute does not exist in the shader code: ' + attributeValues[i].name);
    }
  }

  var Integer nbUniforms[];
  glGetProgramiv(program, GL_ACTIVE_UNIFORMS, nbUniforms);
  if (nbUniforms.size() > 0) {
    for (i = 0; i < nbUniforms[0]; i++) {
      var Size nbReceived[];
      glGetActiveUniform(program, i, 1024, nbReceived, size, type, name);
      //  report( "P: " + i + " - " + size + " - " + type + " - " + name );
  
      Boolean found = false;
      for (j = 0; j < uniformValues.size(); j++) {
        if (name == uniformValues[j].name) {
          found = true;
          break;
        }
      }
      if (!found) {
        report('WARNING: ' + shaderName + ': Uniform not bound:' + name);
      }
    }
  }
  
  var Integer nbAttribs[];
  glGetProgramiv(program, GL_ACTIVE_ATTRIBUTES, nbAttribs);
  if (nbAttribs.size() > 0) {
    for (i = 0; i < nbAttribs[0]; i++) {
      var Size nbReceived[];
      glGetActiveAttrib(program, i, 1024, nbReceived, size, type, name);
      //  report( "A: " + i + " - " + size + " - " + type + " - " + name );
  
      Boolean found = false;
      for (j = 0; j < attributeValues.size(); j++) {
        if (name == attributeValues[j].name) {
          found = true;
          break;
        }
      }
      if (!found) {
        report('WARNING: ' + shaderName + ': Attribute not bound:' + name);
      }
    }
  }
}

operator loadShader(
  io String shaderName,
  io ShaderSource shaders[],
  io ShaderValue uniformValues[],
  io ShaderValue attributeValues[],
  io ShaderProgramParam programParams[],
  io Integer program
) {
  if (!program) {
    program = fglCreateProgramFromShaders(shaderName, shaders, programParams);
    if (program) {
      validateShaderBindings(shaderName, program, uniformValues, attributeValues);
    }
  }
}

operator useProgram(io Integer program) {
  glUseProgram(program);
}