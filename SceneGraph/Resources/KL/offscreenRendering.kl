
//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

#include 'FABRIC_ROOT/SceneGraph/Resources/KL/loadShader.kl'

// #define OGL_INTERNALFORMAT GL_RGBA16F_ARB/* GL_RGBA8 */
// #define OGL_FORMAT GL_RGBA
// #define OGL_TYPE GL_UNSIGNED_BYTE

operator prepareOffscreenRendering(
  io Integer width,
  io Integer height,
  io Integer fboID,
  io Integer prevFBO,
  io Integer colorTextureID,
  io Integer depthTextureID
) {
  // report(">>>prepareOffscreenRendering");
  var Integer integers[];
  integers.resize(1);
  glGetIntegerv(GL_FRAMEBUFFER_BINDING, integers);
  prevFBO = integers[0];

  glEnable(GL_TEXTURE_2D);
  
  var Size sizeArray[];
  sizeArray.resize(2);

  if (fboID > 0) {
    var Integer texWidth, texHeight;

    // Have the dimensions changed?
    glBindTexture(GL_TEXTURE_2D, colorTextureID);
    glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_WIDTH, integers);
    texWidth = integers[0];
    glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_HEIGHT, integers);
    texHeight = integers[0];

    if (width != texWidth || height != texHeight) {
      // Textures need to be deleted first.
      sizeArray[0] = Size(colorTextureID);
      sizeArray[1] = Size(depthTextureID);
      glDeleteTextures(2, sizeArray);

      glBindFramebuffer(GL_FRAMEBUFFER, 0);
      sizeArray[0] = fboID;
      glDeleteFramebuffers(1, sizeArray);

      fboID = colorTextureID = depthTextureID = 0;
    }
  }

  if (fboID == 0) {
    var Data NULL;

    glGenTextures(2, sizeArray);
    colorTextureID = sizeArray[0];
    depthTextureID = sizeArray[1];

    glBindTexture(GL_TEXTURE_2D, colorTextureID);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexImage2D(GL_TEXTURE_2D, 0, OGL_INTERNALFORMAT, width, height, 0, OGL_FORMAT, OGL_TYPE, NULL);

    // Try to use a texture depth component
    glBindTexture(GL_TEXTURE_2D, depthTextureID);

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

    glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, width, height, 0, GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE, NULL);

    // create a framebuffer object
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    glGenFramebuffers(1, sizeArray);
    fboID = sizeArray[0];
    glBindFramebuffer(GL_FRAMEBUFFER, fboID);

    // attach the texture to FBO depth attachment point
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, colorTextureID, 0);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthTextureID, 0);

    // check FBO status
    var Integer status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
    if (status != GL_FRAMEBUFFER_COMPLETE) {
      report('prepareOffscreenRendering: GL_FRAMEBUFFER_COMPLETE failed, CANNOT use FBO\n');

      sizeArray[0] = Size(fboID);
      glDeleteFramebuffers(1, sizeArray);
      fboID = - 1;
    }
  }

  // Switch to off-screen rendering using our FBO
  if (fboID > 0) {
    glBindFramebuffer(GL_FRAMEBUFFER, fboID);
  }
  // report("<<<prepareOffscreenRendering");
}

operator renderOffscreenToView(
  io Integer width,
  io Integer height,
  io Integer prevFBO,
  io Integer colorTextureID,
  io Integer program
) {
  // report(">>>renderOffscreenToView");

  glBindFramebuffer(GL_FRAMEBUFFER, prevFBO);

  glPushAttrib(GL_DEPTH_BUFFER_BIT | GL_VIEWPORT_BIT | GL_TEXTURE_BIT);

  glViewport(0, 0, width, height);
  glDisable(GL_DEPTH_TEST);

  glClearColor(0.0, 1.0, 0.0, 1.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  glUseProgram(program);

  var String name = 'a_position';
  var Integer posLocation = glGetAttribLocation(program, name);
  name = 'a_texCoord';
  var Integer texLocation = glGetAttribLocation(program, name);
  name = 'u_rgbaImage';
  var Integer smpLocation = glGetUniformLocation(program, name);

  // Set the sampler
  glEnable(GL_TEXTURE_2D);
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, colorTextureID);
  glUniform1i(smpLocation, 0);

  // Draw a quad in the upper left with debugging info
  var Vec3 p[4];
  p[0] = Vec3(-1.0, 1.0, 0.0);
  p[1] = Vec3(1.0, 1.0, 0.0);
  p[2] = Vec3(1.0, - 1.0, 0.0);
  p[3] = Vec3(-1.0, - 1.0, 0.0);
  var Vec2 t[4];
  t[0] = Vec2(0.0, 1.0);
  t[1] = Vec2(1.0, 1.0);
  t[2] = Vec2(1.0, 0.0);
  t[3] = Vec2(0.0, 0.0);
  var Integer idx[6];
  idx[0] = 0; idx[1] = 2; idx[2] = 1;
  idx[3] = 0; idx[4] = 3; idx[5] = 2;


  var Data NULL;

  var Size bufferID0;
  var Size bufferID1;
  var Size bufferID2;
  var Size bufferIDArray[];
  bufferIDArray.resize(1);
  glGenBuffers(1, bufferIDArray);
  bufferID0 = bufferIDArray[0];
  glGenBuffers(1, bufferIDArray);
  bufferID1 = bufferIDArray[0];
  glGenBuffers(1, bufferIDArray);
  bufferID2 = bufferIDArray[0];

  glBindBuffer(GL_ARRAY_BUFFER, bufferID0);
  glBufferData(GL_ARRAY_BUFFER, p.dataSize(), p.data(), GL_STATIC_DRAW);
  glEnableVertexAttribArray(posLocation);
  glVertexAttribPointer(posLocation, 3, GL_FLOAT, GL_FALSE, 0, NULL);

  glBindBuffer(GL_ARRAY_BUFFER, bufferID1);
  glBufferData(GL_ARRAY_BUFFER, t.dataSize(), t.data(), GL_STATIC_DRAW);
  glEnableVertexAttribArray(texLocation);
  glVertexAttribPointer(texLocation, 2, GL_FLOAT, GL_FALSE, 0, NULL);

  glBindBuffer(GL_ARRAY_BUFFER, bufferID2);
  glBufferData(GL_ARRAY_BUFFER, idx.dataSize(), idx.data(), GL_STATIC_DRAW);
  glBindBuffer(GL_ARRAY_BUFFER, 0);

  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, bufferID2);
  glDrawElements(GL_TRIANGLES, idx.size(), GL_UNSIGNED_INT, NULL);
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

  glFinish();

  glBindTexture(GL_TEXTURE_2D, 0);

  bufferIDArray[0] = bufferID0;
  glDeleteBuffers(1, bufferIDArray);
  bufferIDArray[0] = bufferID1;
  glDeleteBuffers(1, bufferIDArray);
  bufferIDArray[0] = bufferID2;
  glDeleteBuffers(1, bufferIDArray);

  glPopAttrib();

  // report("<<<renderOffscreenToView");
}

operator renderTextureToView(
  io Integer textureUnit,
  io Integer program
) {
  // report(">>>renderTextureToView");

  if (!program) {
    ShaderSource pixelShader;
    ShaderSource fragmentShader;
    pixelShader.type = GL_VERTEX_SHADER;
    pixelShader.code = '\
      attribute vec4 a_position; \
      attribute vec4 a_texCoord; \
      void main() { \
        gl_TexCoord[0].st = a_texCoord.xy; \
        gl_Position = a_position; \
      }';

    fragmentShader.type = GL_FRAGMENT_SHADER;
    fragmentShader.code = '\
      uniform sampler2D u_rgbaImage; \
      void main() \
      { \
        gl_FragColor = texture2D( u_rgbaImage, gl_TexCoord[0].st ); \
      }';
    ShaderSource shaders[];
    shaders.push(pixelShader);
    shaders.push(fragmentShader);
    ShaderProgramParam programParams[];
    program = fglCreateProgramFromShaders('renderTextureToView', shaders, programParams);
    if (!program) {
      report('Error in renderTextureToView');
      return;
    }
  }

  glUseProgram(program);

  var String name = 'a_position';
  var Integer posLocation = glGetAttribLocation(program, name);
  name = 'a_texCoord';
  var Integer texLocation = glGetAttribLocation(program, name);
  name = 'u_rgbaImage';
  var Integer smpLocation = glGetUniformLocation(program, name);

  // Set the sampler
  glEnable(GL_TEXTURE_2D);
  glDisable(GL_DEPTH_TEST);
  glDisable(GL_CULL_FACE);

  glUniform1i(smpLocation, textureUnit);

  // Draw a quad in the upper left with debugging info
  var Vec3 p[4];
  p[0] = Vec3(-1.0, 1.0, 0.0);
  p[1] = Vec3(1.0, 1.0, 0.0);
  p[2] = Vec3(1.0, - 1.0, 0.0);
  p[3] = Vec3(-1.0, - 1.0, 0.0);
  var Vec2 t[4];
  t[0] = Vec2(0.0, 0.0);
  t[1] = Vec2(1.0, 0.0);
  t[2] = Vec2(1.0, 1.0);
  t[3] = Vec2(0.0, 1.0);
  var Integer idx[6];
  idx[0] = 0; idx[1] = 2; idx[2] = 1;
  idx[3] = 0; idx[4] = 3; idx[5] = 2;

  var Data NULL;

  var Size bufferID0;
  var Size bufferID1;
  var Size bufferID2;
  var Size bufferIDArray[];
  bufferIDArray.resize(1);
  glGenBuffers(1, bufferIDArray);
  bufferID0 = bufferIDArray[0];
  glGenBuffers(1, bufferIDArray);
  bufferID1 = bufferIDArray[0];
  glGenBuffers(1, bufferIDArray);
  bufferID2 = bufferIDArray[0];

  glBindBuffer(GL_ARRAY_BUFFER, bufferID0);
  glBufferData(GL_ARRAY_BUFFER, p.dataSize(), p.data(), GL_STATIC_DRAW);
  glEnableVertexAttribArray(posLocation);
  glVertexAttribPointer(posLocation, 3, GL_FLOAT, GL_FALSE, 0, NULL);

  glBindBuffer(GL_ARRAY_BUFFER, bufferID1);
  glBufferData(GL_ARRAY_BUFFER, t.dataSize(), t.data(), GL_STATIC_DRAW);
  glEnableVertexAttribArray(texLocation);
  glVertexAttribPointer(texLocation, 2, GL_FLOAT, GL_FALSE, 0, NULL);

  glBindBuffer(GL_ARRAY_BUFFER, bufferID2);
  glBufferData(GL_ARRAY_BUFFER, idx.dataSize(), idx.data(), GL_STATIC_DRAW);
  glBindBuffer(GL_ARRAY_BUFFER, 0);

  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, bufferID2);
  glDrawElements(GL_TRIANGLES, idx.size(), GL_UNSIGNED_INT, NULL);
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

  glEnable(GL_DEPTH_TEST);
  glEnable(GL_CULL_FACE);
  // report("<<<renderTextureToView");
}