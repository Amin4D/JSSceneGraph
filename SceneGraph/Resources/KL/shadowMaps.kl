
//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//


function Mat44 symmetricFrustum(Scalar r, Scalar t, Scalar n, Scalar f) {
  var Mat44 result(
    n / r, 0.0, 0.0, 0.0,
    0.0, n / t, 0.0, 0.0,
    0.0, 0.0, -(f + n) / (f - n), - 1.0,
    0.0, 0.0, -(2.0 * f * n) / (f - n), 0.0);
  return result;
}

operator calcLightProjectionMatricies(
  io Scalar near,
  io Scalar far,
  io Scalar fovY,
  io Mat44 lightInvMat,
  io Mat44 lightProjectionMat,
  io Mat44 shadowMat
) {
  //  report( "calcLightProjectionMatricies" );
  
  var Scalar frustumH = tan(fovY / 2) * near;
  var Scalar frustumW = frustumH;

  lightProjectionMat = symmetricFrustum(frustumW, frustumH, near, far);

  var Mat44 biasMat;
  biasMat.setNull();
  biasMat.setDiagonal(0.5);
  biasMat.row3 = Vec4(0.5, 0.5, 0.5, 1.0);

  shadowMat = lightInvMat * lightProjectionMat * biasMat;
}

operator bindShadowMapBuffer(
  io Size textureIndex,
  io OGLRenderTarget depthRenderTarget
) {
  glActiveTexture(GL_TEXTURE0 + textureIndex);
  Integer depthTextureID = depthRenderTarget.textures[depthRenderTarget.depthBuffer].texture.bufferID;
  glBindTexture(GL_TEXTURE_2D, depthTextureID);
}

operator debugShadowMapBuffer(
  io Size colorTextureID
) {
/*
  // report( "debugBuffer" );
  // Create a simple shader for drawing

  // TODO: Validate that we need to store all these states.
  glPushAttrib(GL_DEPTH_BUFFER_BIT | GL_VIEWPORT_BIT | GL_TEXTURE_BIT);
  glDisable(GL_DEPTH_TEST);
  glDisable(GL_CULL_FACE);

  OGLShaderSource vertexShader;
  vertexShader.type = GL_VERTEX_SHADER;
  vertexShader.code = " \
    attribute vec4 a_position; \
    attribute vec4 a_texCoord; \
    void main() { \
      gl_TexCoord[0].st = a_texCoord.xy; \
      gl_Position = a_position; \
    } \
    ";

  OGLShaderSource fragmentShader;
  fragmentShader.type = GL_FRAGMENT_SHADER;
  fragmentShader.code = " \
    uniform sampler2D u_sampler0; \
    void main() \
    { \
      vec2 uv = gl_TexCoord[0].st; \
      gl_FragColor = texture2D( u_sampler0, uv ); \
    } \
    ";

  ShaderSource shaders[];
  shaders.push(vertexShader);
  shaders.push(fragmentShader);
  ShaderProgramParam programParams[];

  var Integer programID = fglCreateProgramFromShaders('debugShadowMap', shaders, programParams);
  glUseProgram(programID);
  
  String positionAttribName = 'a_position';
  String texAttribName = 'a_texCoord';
  String samplerAttribName = 'u_sampler0';

  var Integer posLocation = glGetAttribLocation(programID, positionAttribName);
  var Integer texLocation = glGetAttribLocation(programID, texAttribName);
  var Integer smpLocation = glGetUniformLocation(programID, samplerAttribName);

  // Set the sampler
  glEnable(GL_TEXTURE_2D);
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, colorTextureID);
  glUniform1i(smpLocation, 0);

  // Draw a quad in the upper left with debugging info
  var Vec3 p[4];
  p[0] = Vec3(-1.0, 1.0, 0.5);
  p[1] = Vec3(-0.5, 1.0, 0.5);
  p[2] = Vec3(-0.5, 0.5, 0.5);
  p[3] = Vec3(-1.0, 0.5, 0.5);
  var Vec2 t[4];
  t[0] = Vec2(0.0, 1.0);
  t[1] = Vec2(1.0, 1.0);
  t[2] = Vec2(1.0, 0.0);
  t[3] = Vec2(0.0, 0.0);
  var Integer idx[6];
  idx[0] = 0; idx[1] = 2; idx[2] = 1;
  idx[3] = 0; idx[4] = 3; idx[5] = 2;

  var Size bufferID[];
  bufferID.resize(3);
  var Data NULL;

  glGenBuffers(3, bufferID);

  glBindBuffer(GL_ARRAY_BUFFER, bufferID[0]);
  glBufferData(GL_ARRAY_BUFFER, p.dataSize(), p.data(), GL_STATIC_DRAW);
  glEnableVertexAttribArray(posLocation);
  glVertexAttribPointer(posLocation, 3, GL_FLOAT, GL_FALSE, 0, NULL);

  glBindBuffer(GL_ARRAY_BUFFER, bufferID[1]);
  glBufferData(GL_ARRAY_BUFFER, t.dataSize(), t.data(), GL_STATIC_DRAW);
  glEnableVertexAttribArray(texLocation);
  glVertexAttribPointer(texLocation, 2, GL_FLOAT, GL_FALSE, 0, NULL);

  glBindBuffer(GL_ARRAY_BUFFER, bufferID[2]);
  glBufferData(GL_ARRAY_BUFFER, idx.dataSize(), idx.data(), GL_STATIC_DRAW);
  glBindBuffer(GL_ARRAY_BUFFER, 0);

  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, bufferID[2]);
  glDrawElements(GL_TRIANGLES, idx.size(), GL_UNSIGNED_INT, NULL);
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

  glFinish();

  glDeleteProgram(programID);
  glDeleteBuffers(3, bufferID);
  
  glPopAttrib();
  */
}