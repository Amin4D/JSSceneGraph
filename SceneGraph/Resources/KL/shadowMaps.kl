
//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

#include 'FABRIC_ROOT/SceneGraph/Resources/KL/loadShader.kl'

function Mat44 symmetricFrustum(Scalar r, Scalar t, Scalar n, Scalar f) {
  var Mat44 result(
    n / r, 0.0, 0.0, 0.0,
    0.0, n / t, 0.0, 0.0,
    0.0, 0.0, -(f + n) / (f - n), - 1.0,
    0.0, 0.0, -(2.0 * f * n) / (f - n), 0.0);
  return result;
}

operator calcLightProjectionMatricies(
  io Scalar near,
  io Scalar far,
  io Scalar fovY,
  io Mat44 lightInvMat,
  io Mat44 lightProjectionMat,
  io Mat44 shadowMat
) {
  //  report( "calcLightProjectionMatricies" );
  
  var Scalar frustumH = tan(fovY / 2) * near;
  var Scalar frustumW = frustumH;

  lightProjectionMat = symmetricFrustum(frustumW, frustumH, near, far);

  var Mat44 biasMat;
  biasMat.setNull();
  biasMat.setDiagonal(0.5);
  biasMat.row3 = Vec4(0.5, 0.5, 0.5, 1.0);

  shadowMat = lightInvMat * lightProjectionMat * biasMat;
}

function createDepthMap(io Integer textureId, io Integer mapsize) {

}

function createFBO(io Integer fboId, io Integer textureId) {

}

operator genAndBindShadowMapFBO(
  io Size shadowFBO,
  io Size prevFBO,
  io Size depthTextureID,
  io Size colorTextureID,
  io Integer mapsize
) {
  //  report("genAndBindShadowMapFBO");
  Integer prevFBOs[];
  prevFBOs.resize(1);
  glGetIntegerv(GL_FRAMEBUFFER_BINDING, prevFBOs);
  prevFBO = prevFBOs[0];

  if (depthTextureID == 0) {

    var Data NULL;
    glEnable(GL_TEXTURE_2D);
    
    Size textureIDs[];
    textureIDs.resize(2);
    glGenTextures(2, textureIDs);
    
    /////////////////////////////////////////////////////
    // Depth Texture
    depthTextureID = textureIDs[0];
    glBindTexture(GL_TEXTURE_2D, depthTextureID);

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_R_TO_TEXTURE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC, GL_LEQUAL);
    glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE, GL_INTENSITY);

    glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, mapsize, mapsize, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);

    /////////////////////////////////////////////////////
    // Color Texture
    colorTextureID = textureIDs[1];
    
    glBindTexture(GL_TEXTURE_2D, colorTextureID);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    //NULL means reserve texture memory, but texels are undefined
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, mapsize, mapsize, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);

    /////////////////////////////////////////////////////
    // create a framebuffer object
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    Size shadowFBOs[];
    shadowFBOs.resize(1);
    glGenFramebuffers(1, shadowFBOs);
    shadowFBO = shadowFBOs[0];
    glBindFramebuffer(GL_FRAMEBUFFER, shadowFBO);

    // attach the texture to FBO depth attachment point
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, colorTextureID, 0);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthTextureID, 0);

    // check FBO status
    var Integer status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
    if (status != GL_FRAMEBUFFER_COMPLETE)
      report('GL_FRAMEBUFFER_COMPLETE failed, CANNOT use FBO\n');
  }

  // This is important, if not here, FBO's depthbuffer won't be populated.

  //First step: Render from the light POV to a FBO, store depth values only
  glBindFramebuffer(GL_FRAMEBUFFER, shadowFBO); //Rendering offscreen
  
  
  glPushAttrib(GL_DEPTH_BUFFER_BIT | GL_VIEWPORT_BIT | GL_TEXTURE_BIT);

  // In the case we render the shadowmap to a higher resolution, the viewport must be modified accordingly.
  glViewport(0, 0, mapsize, mapsize);

  // Clear previous frame values
  glClearColor(0.0, 0.0, 0.0, 1.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  glEnable(GL_DEPTH_TEST);
  glEnable(GL_CULL_FACE);
  // Culling switching, rendering only backface, this is done to avoid self-shadowing
  glCullFace(GL_FRONT);

}

operator unbindFBO(
  io Size prevFBO,
) {
  //  report("unbindFBO");

  // unbind FBO
  glBindFramebuffer(GL_FRAMEBUFFER, prevFBO);
  // restore the OpenGL state
  glPopAttrib();
}

operator bindShadowMapBuffer(
  io Size textureIndex,
  io Size depthTextureID
) {
  glActiveTexture(GL_TEXTURE0 + textureIndex);
  glBindTexture(GL_TEXTURE_2D, depthTextureID);
}

operator debugShadowMapBuffer(
  io Size colorTextureID
) {
  // report( "debugBuffer" );
  // Create a simple shader for drawing

  // TODO: Validate that we need to store all these states.
  glPushAttrib(GL_DEPTH_BUFFER_BIT | GL_VIEWPORT_BIT | GL_TEXTURE_BIT);
  glDisable(GL_DEPTH_TEST);
  glDisable(GL_CULL_FACE);

  ShaderSource vertexShader;
  vertexShader.type = GL_VERTEX_SHADER;
  vertexShader.code = " \
    attribute vec4 a_position; \
    attribute vec4 a_texCoord; \
    void main() { \
      gl_TexCoord[0].st = a_texCoord.xy; \
      gl_Position = a_position; \
    } \
    ";

  ShaderSource fragmentShader;
  fragmentShader.type = GL_FRAGMENT_SHADER;
  fragmentShader.code = " \
    uniform sampler2D u_sampler0; \
    void main() \
    { \
      vec2 uv = gl_TexCoord[0].st; \
      gl_FragColor = texture2D( u_sampler0, uv ); \
    } \
    ";

  ShaderSource shaders[];
  shaders.push(vertexShader);
  shaders.push(fragmentShader);
  ShaderProgramParam programParams[];

  var Integer programID = fglCreateProgramFromShaders('debugShadowMap', shaders, programParams);
  glUseProgram(programID);
  
  String positionAttribName = 'a_position';
  String texAttribName = 'a_texCoord';
  String samplerAttribName = 'u_sampler0';

  var Integer posLocation = glGetAttribLocation(programID, positionAttribName);
  var Integer texLocation = glGetAttribLocation(programID, texAttribName);
  var Integer smpLocation = glGetUniformLocation(programID, samplerAttribName);

  // Set the sampler
  glEnable(GL_TEXTURE_2D);
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, colorTextureID);
  glUniform1i(smpLocation, 0);

  // Draw a quad in the upper left with debugging info
  var Vec3 p[4];
  p[0] = Vec3(-1.0, 1.0, 0.5);
  p[1] = Vec3(-0.5, 1.0, 0.5);
  p[2] = Vec3(-0.5, 0.5, 0.5);
  p[3] = Vec3(-1.0, 0.5, 0.5);
  var Vec2 t[4];
  t[0] = Vec2(0.0, 1.0);
  t[1] = Vec2(1.0, 1.0);
  t[2] = Vec2(1.0, 0.0);
  t[3] = Vec2(0.0, 0.0);
  var Integer idx[6];
  idx[0] = 0; idx[1] = 2; idx[2] = 1;
  idx[3] = 0; idx[4] = 3; idx[5] = 2;

  var Size bufferID[];
  bufferID.resize(3);
  var Data NULL;

  glGenBuffers(3, bufferID);

  glBindBuffer(GL_ARRAY_BUFFER, bufferID[0]);
  glBufferData(GL_ARRAY_BUFFER, p.dataSize(), p.data(), GL_STATIC_DRAW);
  glEnableVertexAttribArray(posLocation);
  glVertexAttribPointer(posLocation, 3, GL_FLOAT, GL_FALSE, 0, NULL);

  glBindBuffer(GL_ARRAY_BUFFER, bufferID[1]);
  glBufferData(GL_ARRAY_BUFFER, t.dataSize(), t.data(), GL_STATIC_DRAW);
  glEnableVertexAttribArray(texLocation);
  glVertexAttribPointer(texLocation, 2, GL_FLOAT, GL_FALSE, 0, NULL);

  glBindBuffer(GL_ARRAY_BUFFER, bufferID[2]);
  glBufferData(GL_ARRAY_BUFFER, idx.dataSize(), idx.data(), GL_STATIC_DRAW);
  glBindBuffer(GL_ARRAY_BUFFER, 0);

  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, bufferID[2]);
  glDrawElements(GL_TRIANGLES, idx.size(), GL_UNSIGNED_INT, NULL);
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

  glFinish();

  glDeleteProgram(programID);
  glDeleteBuffers(3, bufferID);
  
  glPopAttrib();
}