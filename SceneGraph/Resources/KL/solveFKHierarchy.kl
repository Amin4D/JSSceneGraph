
//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//


operator solveFKBone(
  io Xfo pose[],
  io Bone bones[],
  io Integer index,
  io Xfo local
) {
  if (bones[index].parent == - 1) {
    pose[index] = local;
  }
  else {
    pose[index] = pose[bones[index].parent].project(local);
  }
}

operator solveInvFKBone(
  io Xfo pose[],
  io Bone bones[],
  io Integer index,
  io Xfo local
) {
  if (bones[index].parent == - 1) {
    local = pose[index];
  }
  else {
    local = pose[bones[index].parent].invProject(pose[index]);
  }
}

operator solveFKHierarchy(
  io Xfo pose[],
  io Bone bones[],
  io Integer indices[],
  io Xfo local[]
) {
  for (var Integer i = 0; i < indices.size(); i++) {
    if (bones[indices[i]].parent == - 1) {
      pose[indices[i]] = local[i];
    }
    else {
      pose[indices[i]] = pose[bones[indices[i]].parent].project(local[i]);
    }
  }
}

operator solveInvFKHierarchy(
  io Xfo srcpose[],
  io Bone srcbones[],
  io Bone tgtbones[],
  io Integer srcIndices[],
  io Integer tgtIndices[],
  io Boolean invReproject,
  io Xfo local[]
) {
  for (var Integer i = 0; i < srcIndices.size(); i++) {
    var Bone srcBone = srcbones[srcIndices[i]];
    var Bone tgtBone = tgtbones[tgtIndices[i]];
    if (srcBone.parent == - 1) {
      local[i] = srcpose[srcIndices[i]];
    }
    else {
      local[i] = srcpose[srcBone.parent].invProject(srcpose[srcIndices[i]]);
    }
    
    // we need to compensate for hierarchical offsets
    // when mapping from one skeleton to another
    if(tgtBone.parent != -1 && invReproject){
      var Xfo offset = srcBone.referenceLocalPose.invProject(tgtBone.referenceLocalPose);
      local[i] = local[i].project(offset);
    }
  }
}

operator solveGlobalPose(
  io Xfo pose[],
  io Bone bones[],
  io Integer indices[],
  io Xfo global[]
) {
  for (var Integer i = 0; i < indices.size(); i++) {
    pose[indices[i]] = global[i];
  }
}

operator solveInvGlobalPose(
  io Xfo pose[],
  io Bone bones[],
  io Integer indices[],
  io Xfo global[]
) {
  for (var Integer i = 0; i < indices.size(); i++) {
    global[i] = pose[indices[i]];
  }
}

operator solveChain(
  io Xfo pose[],
  io Xfo chainpose[],
  io Bone bones[],
  io Integer indices[],
  io Xfo local[]
) {
  if (indices.size() != local.size() || indices.size() != chainpose.size()) {
    report('solveChain Error: indices.size() != local.size() || indices.size() != chainpose.size()');
    return;
  }

  for (var Integer i = 0; i < indices.size(); i++) {
    if (bones[indices[i]].parent == - 1) {
      chainpose[i] = local[i];
    }
    else {
      chainpose[i] = pose[bones[indices[i]].parent].project(local[i]);
    }
    pose[indices[i]] = chainpose[i];
  }
}

operator solveInvChain(
  io Xfo pose[],
  io Xfo chainpose[],
  io Bone bones[],
  io Integer indices[],
  io Xfo local[]
) {
  if (indices.size() != local.size() || indices.size() != chainpose.size()) {
    report('solveChain Error: indices.size() != local.size() || indices.size() != chainpose.size()');
    return;
  }

  for (var Integer i = 0; i < indices.size(); i++) {
    chainpose[i] = pose[indices[i]];
    if (bones[indices[i]].parent == - 1) {
      local[i] = chainpose[i];
    }
    else {
      local[i] = pose[bones[indices[i]].parent].invProject(chainpose[i]);
    }
  }
}

