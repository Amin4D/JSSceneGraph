
//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

operator solveIK2Bone(
  io Xfo pose[],
  io Bone bones[],
  io Integer boneA,
  io Integer boneB,
  io Integer targetParent,
  io Integer upvectorParent,
  io Boolean flipUpvector,
  io Xfo local,
  io Xfo target,
  io Xfo upvector
) {

  if (bones[boneA].parent != - 1) {
    pose[boneA] = local * pose[bones[boneA].parent];
  }

  pose[boneB] = bones[boneB].referenceLocalPose * pose[boneA];

  // compute the manipulator positions
  var Vec3 targetPos = pose[targetParent].transform(target.tr);
  var Vec3 upvectorPos = pose[upvectorParent].transform(upvector.tr);

  // compute the sides of the triangles and their lengths
  var Vec3 sideA = upvectorPos - (pose[boneA].tr + targetPos) * 0.5;
  var Vec3 sideC = targetPos - pose[boneA].tr;
  var Scalar lengthA = bones[boneA].length;
  var Scalar lengthB = bones[boneB].length;
  var Scalar lengthC = sideC.norm();

  // compute the direction of the first bone
  var Vec3 xAxis;
  var Vec3 zAxis = sideA.cross(sideC).unit();
  if (lengthC < lengthA + lengthB) {
    var Scalar angle = - acos((lengthA * lengthA + lengthC * lengthC - lengthB * lengthB) / (2.0 * lengthA * lengthC));
    var Quat q = axisAndAngleToQuat(zAxis, angle);
    xAxis = q.transform(sideC).unit();
  } else {
    xAxis = sideC.unit();
  }
    
  // orient bones
  var Vec3 yAxis = upvectorPos - targetPos;
  if(flipUpvector)
    yAxis = yAxis.neg();
  pose[boneA].ori = directionToQuat(xAxis,yAxis);
  pose[boneB].tr = pose[boneA].tr + xAxis * bones[boneA].length;
  xAxis = targetPos - pose[boneB].tr;
  pose[boneB].ori = directionToQuat(xAxis,yAxis);
}

operator solveInvIK2Bone(
  io Xfo srcpose[],
  io Bone srcbones[],
  io Bone tgtbones[],
  io Integer srcBoneA,
  io Integer srcBoneB,
  io Integer tgtBoneA,
  io Integer tgtBoneB,
  io Integer tgtTargetParent,
  io Integer tgtUpvectorParent,
  io Xfo local,
  io Xfo target,
  io Xfo upvector
) {
  var Bone srcA = srcbones[srcBoneA];
  var Bone srcB = srcbones[srcBoneB];
  
  local = srcpose[srcBoneA];
  if(srcA.parent != -1)
    local = srcpose[srcA.parent].invProject(local);

  // now also project this properly into the target    
  target = srcpose[srcBoneB];
  target.tr = target.transform(Vec3(srcB.length, 0.0, 0.0));
  upvector = srcpose[srcBoneB];
  
  // let's compute the orthogonal centerpoint
  var Vec3 adjacent = (target.tr - srcpose[srcBoneA].tr);
  var Vec3 hypotenuse = (srcpose[srcBoneB].tr - srcpose[srcBoneA].tr);
  var Scalar angle = adjacent.unit().angle(hypotenuse.unit());
  var Scalar length = cos(angle) * hypotenuse.norm();
  adjacent = adjacent.unit() * length + srcpose[srcBoneA].tr;
  upvector.tr = (srcpose[srcBoneB].tr - adjacent) * 2.0 + srcpose[srcBoneB].tr;
  
  // project into parent spaces
  target = srcpose[tgtTargetParent].invProject(target);
  upvector = srcpose[tgtUpvectorParent].invProject(upvector);
}