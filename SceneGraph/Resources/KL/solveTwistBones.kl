
//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//


operator solveBlendBones(
  io Xfo pose[],
  io Bone bones[],
  io Integer base,
  io Integer end,
  io Integer blendBones[],
  io Xfo blendBoneOffsets[],
  io Scalar blendWeights[]
) {
  if (blendBones.size() != blendWeights.size()) {
    // TODO: throw an assert once we are able to do that.
    report('Error: blendBones count does not match blendWeights count');
    return;
  }
  
  Xfo baseXfo = pose[base];
  Xfo endXfo = pose[end];
  Xfo bone;

  for (var Integer i = 0; i < blendBones.size(); i++) {
    if(bones[blendBones[i]].parent == -1)
      bone = bones[blendBones[i]].referencePose;
    else
      bone = pose[bones[blendBones[i]].parent].project(bones[blendBones[i]].referenceLocalPose);

    bone.ori = nlerp(baseXfo.ori, endXfo.ori, blendWeights[i]);
    pose[blendBones[i]] = bone.project(blendBoneOffsets[i]);
  }
}

operator solveTwistBones(
  io Xfo pose[],
  io Bone bones[],
  io Integer base,
  io Integer end,
  io Quat endOffset,
  io Integer twistBones[],
  io Scalar twistWeights[]
) {
  if (twistBones.size() != twistWeights.size()) {
    // TODO: throw an assert once we are able to do that.
    report('Error: twistBone count does not match twistWeights count');
    return;
  }

  Xfo baseXfo = pose[base];
  Xfo endXfo = pose[end];
  endXfo.ori = endOffset * endXfo.ori;

  Vec3 baseVec = (endXfo.tr - baseXfo.tr).unit();
  Vec3 endVec = endXfo.ori.getXaxis();
  endXfo.ori = makeQuatFrom2Vectors(endVec, baseVec) * endXfo.ori;

  for (var Integer i = 0; i < twistBones.size(); i++) {
    if(bones[twistBones[i]].parent == -1)
      pose[twistBones[i]] = bones[twistBones[i]].referencePose;
    else
      pose[twistBones[i]] = pose[bones[twistBones[i]].parent].project(bones[twistBones[i]].referenceLocalPose);
    pose[twistBones[i]].ori = nlerp(baseXfo.ori, endXfo.ori, twistWeights[i]);
  }
}