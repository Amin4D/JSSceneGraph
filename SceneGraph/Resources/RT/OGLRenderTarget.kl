
//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//



function OGLRenderTarget.genTextures() {

  Integer i, maxColorBuffers;
//  glGetIntegerv(GL_MAX_COLOR_ATTACHMENTS, maxColorBuffers);
//  self.numColorBuffers = 0;
//  for(i=0; i<self.textures.size(); i++){
//    if(self.textures[i].type == COLOR_BUFFER)
//      self.numColorBuffers++;
//  }
  
  if(maxColorBuffers < self.numColorBuffers){
    report("Your OpenGL implementation supports only " + maxColorBuffers + " but " + self.numColorBuffers + " are needed");
    return;
  }
  //Create Frame Buffer Object
  Size fbos[];
  fbos.resize(1);
  glGenFramebuffers(1, fbos);
  self.fbo = fbos[0];
  
  glBindFramebuffer(GL_FRAMEBUFFER, self.fbo);
  
  self.numColorBuffers = 0;
  Size textureIDs[];
  textureIDs.resize(1);
  
  for(i=0; i<self.textures.size(); i++){
    switch(self.textures[i].type){
      case 1://self.DEPTH_BUFFER:
        {
          if(self.depthBuffer != -1){
            report( "Creating 2 or more depth buffers is not possible!");
            break;
          }
          if(self.hasDepthBufferTexture){
            report( "A depth buffer texture has already been created, can not create another depth texture");
            break;
          }
          if(self.textures[i].texture.glInternalFormat != GL_DEPTH_COMPONENT){
            report( "A Depth Buffer must impliment a GL_DEPTH_COMPONENT internal format.");
            break;
          }
          
          self.textures[i].texture.getTexture(self.width, self.height);
          if(self.textures[i].texture.bufferID==0){
            report("Error generating texture");
            break;
          }
          
          glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, self.textures[i].texture.bufferID, 0);
          
          self.depthBuffer = i;
          self.hasDepthBufferTexture = true;
        }
        break;
      case 2://self.COLOR_BUFFER:
        {
          
          self.textures[i].texture.getTexture(self.width, self.height);
          if(self.textures[i].texture.bufferID==0){
            report("Error generating texture");
            continue;
          }
          glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0+self.numColorBuffers, GL_TEXTURE_2D, self.textures[i].texture.bufferID, 0);
          
          self.numColorBuffers++;
        }
        break;
    }
  }

  
  //Depth buffer only
  if(self.numColorBuffers <= 0){
    glDrawBuffer(GL_NONE);
    glReadBuffer(GL_NONE);
  }
  /*
  var Integer status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
  if (status != GL_FRAMEBUFFER_COMPLETE){
    switch(status){
      case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        report( "Error: incomplete attachment");
        break;
      case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        report( "Error: missing attachment");
        break;
      case GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        report( "Error: dimensions of rendertarget errorness");
        break;
      case GL_FRAMEBUFFER_INCOMPLETE_FORMATS:
        report( "Error: errorness format");
        break;
      case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER:
        report( "Error: missing draw buffer");
        break;
      case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER:
        report( "Error: missing read buffer");
        break;
      case GL_FRAMEBUFFER_UNSUPPORTED:
        report( "Error: rendertarget not supported");
        break;
      default:
        report( "Error: unkown error");
        break;
    }
  }
*/
}
  
function OGLRenderTarget.prebind(
  Integer currWidth,
  Integer currHeight
) {
  if(self.fbo > 0){
    if (self.width != currWidth || self.height != currHeight) {
    
      Size numTextures = (self.hasDepthBufferTexture ? 1 : 0) + self.numColorBuffers;
      Size bufferIDs[];
      bufferIDs.resize(numTextures);
      
      for(Integer i=0; i<self.textures.size(); i++){
        bufferIDs[i] = self.textures[i].texture.bufferID;
        self.textures[i].texture.bufferID = 0;
      }
      // Textures need to be deleted first.;
      glDeleteTextures(numTextures, bufferIDs);

      glBindFramebuffer(GL_FRAMEBUFFER, 0);
      bufferIDs.resize(1);
      bufferIDs[0] = self.fbo;
      glDeleteFramebuffers(1, bufferIDs);

      self.fbo = 0;
      self.depthBuffer = -1;
      self.hasDepthBufferTexture = false;
    }
  }
}

function OGLRenderTarget.bind() {
  if(self.fbo==0){
    self.genTextures();
  }
  Integer prevFbos[];
  prevFbos.resize(1);
  glGetIntegerv(GL_FRAMEBUFFER_BINDING, prevFbos);
  self.prevFbo = prevFbos[0];
  
  glBindFramebuffer(GL_FRAMEBUFFER, self.fbo);
  
  glPushAttrib(GL_VIEWPORT_BIT);
  glViewport(0,0, self.width, self.height);
  
  
  Size options = 0;
  if(self.clearDepth){
    options = options | GL_DEPTH_BUFFER_BIT;
  }
  if(self.numColorBuffers > 0 && self.clearColorFlag){
    options = options | GL_COLOR_BUFFER_BIT;
    glClearColor(self.clearColor.r, self.clearColor.g, self.clearColor.b, 1.0);
  }
  glClear(options);
  
  // Note: I'mnot sure if I need to do this every frame
  //Depth buffer only
  if(self.numColorBuffers <= 0){
    glDrawBuffer(GL_NONE);
    glReadBuffer(GL_NONE);
  }
  
  glEnable(self.enableOptions);
  glCullFace(self.cullFace);
}

function OGLRenderTarget.unbind() {
  if(self.fbo==0){
    report("Error: FBO not generated");
  }
  // restore the OpenGL state
  glPopAttrib();
  glBindFramebuffer(GL_FRAMEBUFFER, self.prevFbo);		
}

function OGLRenderTarget.draw() {
  if(self.fbo==0){
    report("Error: FBO not generated");
  }
  // restore the OpenGL state
  glPopAttrib();
  glBindFramebuffer(GL_FRAMEBUFFER, self.prevFbo);		
}
