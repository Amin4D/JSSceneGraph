
//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//

function OGLShaderProgram(String name) {
  self.name = name;
  self.programId = 0;
}

function Integer OGLShaderProgram.createAndCompileShader(OGLShaderSource shadersrc) {
  var Integer shaderID = glCreateShader(shadersrc.type);
  if (shaderID == 0) {
    report(self.name + ' : glCreateShader failed');
    return 0;
  }

  // Load and compile the shader source
  var Integer strlens[];
  var String srcs[];
  strlens.push(Integer(shadersrc.code.length()));
  srcs.push(shadersrc.code);
  glShaderSource(shaderID, 1, srcs, strlens);
  glCompileShader(shaderID);

  // Check the compile status
  var Integer compiled[];
  compiled.push(0);
  glGetShaderiv(shaderID, GL_COMPILE_STATUS, compiled);
  if (compiled[0] == 0)
    report(self.name + ' : Shader compilation failed:');

  var Integer infoLen[];
  infoLen.resize(1);
  glGetShaderiv(shaderID, GL_INFO_LOG_LENGTH, infoLen);

  if (infoLen[0] > 1) {
    if (compiled[0] > 0) {
      report(self.name + ' : Shader compilation succeeded with warnings:');
    }
    var String infoLog;
    var Size bufferSize[];
    var Size bufferTotalSize = 0;
    for(var Size i=0;i<infoLen.size();i++)
    {
      bufferSize.push(Size(infoLen[i]));
      bufferTotalSize += bufferSize[i];
    }
      
    glGetShaderInfoLog(shaderID, bufferTotalSize, bufferSize, infoLog);
    report(infoLog);
  }
  else if (!compiled) {
    report('<Unknown reason>');
  }

  if (!compiled) {
    glDeleteShader(shaderID);
    return 0;
  }

  return shaderID;
}


function OGLShaderProgram.validateShaderBindings() {
  var String name, typeName;
  var Integer i, j;

  for (i = 0; i < self.uniformValues.size(); i++) {
    self.uniformValues[i].location = glGetUniformLocation(self.programId, self.uniformValues[i].name);
    if (self.uniformValues[i].location == - 1) {
      report('ERROR: ' + self.name + ': Attribute does not exist in the shader code: ' + self.uniformValues[i].name);
    }
  }

  for (i = 0; i < self.attributeValues.size(); i++) {
    self.attributeValues[i].location = glGetAttribLocation(self.programId, self.attributeValues[i].name);
    if (self.attributeValues[i].location == - 1) {
      report('ERROR: ' + self.name + ': Attribute does not exist in the shader code: ' + self.attributeValues[i].name);
    }
  }
  if(!self.debug){
    return;
  }

  var Integer nbUniforms[];
  nbUniforms.push(0);
  glGetProgramiv(self.programId, GL_ACTIVE_UNIFORMS, nbUniforms);
  for (i = 0; i < nbUniforms[0]; i++) {
    var Integer size[];
    var Size type[];
    var Size nbReceived[];
    size.push(0);
    type.push(Size(0));
    nbReceived.push(Size(0));
    glGetActiveUniform(self.programId, i, 1024, nbReceived, size, type, name);
    if(self.debug){
      report( "U: " + i + " - " + size + " - " + type + " - " + name );
    }

    Boolean found = false;
    for (j = 0; j < self.uniformValues.size(); j++) {
      if (name == self.uniformValues[j].name) {
        found = true;
        break;
      }
    }
    if (!found) {
      report('WARNING: ' + self.name + ': Uniform not bound:' + name);
    }
  }
  
  var Integer nbAttribs[];
  nbAttribs.push(0);
  glGetProgramiv(self.programId, GL_ACTIVE_ATTRIBUTES, nbAttribs);
  for (i = 0; i < nbAttribs[0]; i++) {
    var Integer size[];
    var Size type[];
    var Size nbReceived[];
    size.push(0);
    type.push(Size(0));
    nbReceived.push(Size(0));
    glGetActiveAttrib(self.programId, i, 1024, nbReceived, size, type, name);
    if(self.debug){
      report( "A: " + i + " - " + size + " - " + type + " - " + name );
    }

    Boolean found = false;
    for (j = 0; j < self.attributeValues.size(); j++) {
      if (name == self.attributeValues[j].name) {
        found = true;
        break;
      }
    }
    if (!found) {
      report('WARNING: ' + self.name + ': Attribute not bound:' + name);
    }
  }
}





function OGLShaderProgram.createProgramFromShaders() {
  if (self.shaderSources.size() == 0) {
    report(self.name + ' : No shaders given to build a self.programId from.');
    return;
  }

  if(self.debug){
    report("createProgramFromShaders:");
  }
  
  var Integer shaderIDs[];
  for (var Size i = 0; i < self.shaderSources.size(); i++) {
    var Integer shaderID = self.createAndCompileShader(self.shaderSources[i]);
    if (shaderID == 0)
      break;
    shaderIDs.push(shaderID);
  }

  if (shaderIDs.size() == self.shaderSources.size()) {
    self.programId = glCreateProgram();
    if (self.programId != 0) {
      for (var Size i = 0; i < shaderIDs.size(); i++) {
        glAttachShader(self.programId, shaderIDs[i]);
      }
      // The self.programId parameters need to be added before linking
      for (var Size i = 0; i < self.programParams.size(); i++) {
        glProgramParameteriEXT(self.programId, self.programParams[i].id, self.programParams[i].value);
      }

      glLinkProgram(self.programId);

      var Integer linked[];
      linked.push(0);
      glGetProgramiv(self.programId, GL_LINK_STATUS, linked);
      if (linked[0] == 0) {
        report(self.name + ' : Program linking failed:');
      }

      var Integer infoLen[];
      infoLen.resize(1);
      glGetProgramiv(self.programId, GL_INFO_LOG_LENGTH, infoLen);

      if (infoLen.size() > 0 && infoLen[0] > 1) {
        if (linked.size() > 0 || linked[0] > 0) {
          report(self.name + ' : Program linking succeeded, with warnings:');
        }
        var Size bufferSize[];
        var Size bufferTotalSize = 0;
        for(var Size i=0;i<infoLen.size();i++)
        {
          bufferSize.push(Size(infoLen[i]));
          bufferTotalSize += bufferSize[i];
        }

        var String infoLog;
        glGetProgramInfoLog(self.programId, bufferTotalSize, bufferSize, infoLog);
        report(infoLog);
      }
      else if (!linked) {
        report('<Unknown reason>');
      }

      if (!linked) {
        glDeleteProgram(self.programId);
        self.programId = 0;
      }
    }
  }
  for (var Size i = 0; i < shaderIDs.size(); i++) {
    glDeleteShader(shaderIDs[i]);
  }
  if (self.programId != 0) {
    self.validateShaderBindings();
  }
}

function OGLShaderProgram.loadShader() {
  if (!self.programId) {
    self.createProgramFromShaders();
  }
  glUseProgram(self.programId);
  
  glPushAttrib(GL_ENABLE_BIT);
  for(Integer i=0; i<self.enableOptions.size(); i++){
    glEnable(self.enableOptions[i]);
    if(self.enableOptions[i]==GL_BLEND){
      glBlendFunc(self.blendModeSfactor, self.blendModeDfactor);
    }
  }
  glCullFace(self.cullFace);
}

function OGLShaderProgram.unloadShader() {
  glPopAttrib();
}

//////////////////////////////////////////////////////////
// Interfaces for loading Uniform values.
// Note: Once KL support polymorphic functions,
// these can all have the same name.
// Note2: Maybe we should drop the uniformId system, and
// store the location values in the material node instead
// of the shader.

function Integer OGLShaderProgram.getUniformLocation(
  Integer uniformId
) {
  for (Integer i = 0; i < self.uniformValues.size(); i++) {
    if (self.uniformValues[i].id == uniformId) {
      return self.uniformValues[i].location;
    }
  }
  return -1;
}

/*
PT 28-06-12 this function refuses to compile...
error: not all paths return a value
function Integer OGLShaderProgram.getUniformLocationByName(
  String name
) {
  if(self.programId!=0){
    return glGetAttribLocation(self.programId, name);
  }else{
    return -1;
  }
}
*/

function Boolean OGLShaderProgram.validateUniformBinding(
  Integer location,
  Size dataSize
) {
  var String name, typeName;
  var Integer i, j;

  var Integer nbUniforms[];
  nbUniforms.push(0);
  glGetProgramiv(self.programId, GL_ACTIVE_UNIFORMS, nbUniforms);
  for (i = 0; i < nbUniforms[0]; i++) {
    var Integer size[];
    var Size type[];
    var Size nbReceived[];
    size.push(0);
    type.push(Size(0));
    nbReceived.push(Size(0));
    glGetActiveUniform(self.programId, i, 1024, nbReceived, size, type, name);
    Integer activeUniformLocation = glGetUniformLocation(self.programId, name);
    if(activeUniformLocation == location){
      report("Loading :"+ name);
     // if(dataSize <= size[0]){
        return true;
     // }else{
     //   report("ERROR: The uniform size is not big enough to contain the given data");
     //   return false;
     // }
    }
  }
  report("ERROR: The uniform is not active");
  return false;
}


function OGLShaderProgram.loadBooleanUniform(
  Integer location,
  Boolean value
) {
  if(self.programId==0){
    report("ERROR: Shader not in use");
    return;
  }
  if (location != - 1) {
    if(self.debug){
    //  self.validateUniformBinding(location, value.dataSize());
    }
    glUniform1i(location, (value ? 1 : 0));
  }
  else{
    report("Invalid Uniform Locations");
  }
}

function OGLShaderProgram.loadIntegerUniform(
  Integer location,
  Integer value
) {
  if(self.programId==0){
    report("ERROR: Shader not in use");
    return;
  }
  if (location != - 1) {
    if(self.debug){
      self.validateUniformBinding(location, value.dataSize());
    }
    glUniform1i(location, value);
  }
  else{
    report("Invalid Uniform Locations");
  }
}

function OGLShaderProgram.loadScalarUniform(
  Integer location,
  Scalar value
) {
  if(self.programId==0){
    report("ERROR: Shader not in use");
    return;
  }
  if (location != - 1) {
    if(self.debug){
      self.validateUniformBinding(location, value.dataSize());
    }
    glUniform1f(location, value);
  }
  else{
    report("Invalid Uniform Locations");
  }
}

function OGLShaderProgram.loadVec2Uniform(
  Integer location,
  Vec2 value
) {
  if(self.programId==0){
    report("ERROR: Shader not in use");
    return;
  }
  if (location != - 1) {
    if(self.debug){
      self.validateUniformBinding(location, value.dataSize());
    }
    glUniform2f(location, value.x, value.y);
  }
  else{
    report("Invalid Uniform Locations");
  }
}

function OGLShaderProgram.loadVec3Uniform(
  Integer location,
  Vec3 value
) {
  if(self.programId==0){
    report("ERROR: Shader not in use");
    return;
  }
  if (location != - 1) {
    if(self.debug){
      self.validateUniformBinding(location, value.dataSize());
    }
    glUniform3f(location, value.x, value.y, value.z);
  }
  else{
    report("Invalid Uniform Locations");
  }
}

function OGLShaderProgram.loadVec4Uniform(
  Integer location,
  Vec4 value
) {
  if(self.programId==0){
    report("ERROR: Shader not in use");
    return;
  }
  if (location != - 1) {
    if(self.debug){
      self.validateUniformBinding(location, value.dataSize());
    }
    glUniform4f(location, value.x, value.y, value.z, value.t);
  }
  else{
    report("Invalid Uniform Locations");
  }
}

function OGLShaderProgram.loadColorUniform(
  Integer location,
  Color value
) {
  if(self.programId==0){
    report("ERROR: Shader not in use");
    return;
  }
  if (location != - 1) {
    if(self.debug){
      self.validateUniformBinding(location, value.dataSize());
    }
    glUniform4f(location, value.r, value.g, value.b, value.a);
  }
  else{
    report("Invalid Uniform Locations");
  }
}

function OGLShaderProgram.loadMat33Uniform(
  Integer location,
  Mat33 value
) {
  if(self.programId==0){
    report("ERROR: Shader not in use");
    return;
  }
  if (location != - 1) {
    var Mat33 values[];
    values.push(value);
    glUniformMatrix3fv(location, 1, false, values);
  }
  else{
    report("Invalid Uniform Locations");
  }
}

function OGLShaderProgram.loadMat44Uniform(
  Integer location,
  Mat44 value
) {
  if(self.programId==0){
    report("ERROR: Shader not in use");
    return;
  }
  if (location != - 1) {
    if(self.debug){
      self.validateUniformBinding(location, value.dataSize());
    }
    var Mat44 values[];
    values.push(value);
    glUniformMatrix4fv(location, 1, false, values);
  }
  else{
    report("Invalid Uniform Locations");
  }
}

function OGLShaderProgram.loadMat44UniformArray(
  Integer location,
  io Mat44 values[] /* PT 28-06-11 I'm not sure why values is an l-value in the following call */
) {
  if(self.programId==0){
    report("ERROR: Shader not in use");
    return;
  }
  if (location != - 1) {
    glUniformMatrix4fv(location, values.size(), false, values);
  }
  else{
    report("Invalid Uniform Locations");
  }
}

//////////////////////////////////////////////////////////
// Interfaces for loading buffers.


function Integer OGLShaderProgram.getAttributeLocation(
  Integer attributeId
) {
  for (Integer i = 0; i < self.attributeValues.size(); i++) {
    if (self.attributeValues[i].id == attributeId) {
      return self.attributeValues[i].location;
    }
  }
  return -1;
}


