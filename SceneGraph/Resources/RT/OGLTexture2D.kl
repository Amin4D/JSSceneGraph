
//
// Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
//


function OGLTexture2D.bind(
  Size width,
  Size height,
  Data pixels,
  Size nbPixels,
  Size glSrcDataType,
  io Integer textureUnit
) {
//  report("createTextureFromImage  bufferID:"+self.bufferID + " textureUnit:"+textureUnit  + " nbPixels:"+nbPixels );
  if(nbPixels > 0){
    if (self.bufferID == 0) {
      var Size buffers[];
      buffers.resize(1);
      glGenTextures(1, buffers);
      self.bufferID = buffers[0];
      glActiveTexture(GL_TEXTURE0 + textureUnit);
      glBindTexture(GL_TEXTURE_2D, self.bufferID);
  
      // glTexEnv( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE ); //set texture environment parameters
  
      //Generate the texture
      glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
      if (nbPixels == (width * height))
        glTexImage2D(GL_TEXTURE_2D, 0, self.glInternalFormat, width, height, 0, self.glFormat, self.glType, pixels);
  
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
  
    }
    else {
      glActiveTexture(GL_TEXTURE0 + textureUnit);
      glBindTexture(GL_TEXTURE_2D, self.bufferID);
    }
  }
}

function OGLTexture2D.bindImageLDR(
  io Size width,
  io Size height,
  io RGBA bitmap[],
  io Integer textureUnit
) {
  self.bind(width, height, bitmap.data(), bitmap.size(), GL_RGBA, textureUnit);
}

function OGLTexture2D.bindImageHDR(
  io Size width,
  io Size height,
  io Color bitmap[],
  io Integer textureUnit
) {
  self.bind(width, height, bitmap.data(), bitmap.size(), GL_RGBA16F_ARB, textureUnit);
}

function OGLTexture2D.renderToView(
  Integer textureUnit,
  io OGLShaderProgram shaderProgram
) {
  // report(">>>renderTextureToView");

  if (shaderProgram.shaderSources.size() == 0) {
    
    OGLShaderSource pixelShader;
    OGLShaderSource fragmentShader;
    pixelShader.type = GL_VERTEX_SHADER;
    pixelShader.code = '\
      attribute vec4 a_position; \
      attribute vec4 a_texCoord; \
      void main() { \
        gl_TexCoord[0].st = a_texCoord.xy; \
        gl_Position = a_position; \
      }';

    fragmentShader.type = GL_FRAGMENT_SHADER;
    fragmentShader.code = '\
      uniform sampler2D u_rgbaImage; \
      void main() \
      { \
        gl_FragColor = texture2D( u_rgbaImage, gl_TexCoord[0].st ); \
      }';
    shaderProgram.shaderSources.push(pixelShader);
    shaderProgram.shaderSources.push(fragmentShader);
  }
  shaderProgram.loadShader();

  var String name = 'a_position';
  var Integer posLocation = glGetAttribLocation(shaderProgram.programId, name);
  name = 'a_texCoord';
  var Integer texLocation = glGetAttribLocation(shaderProgram.programId, name);
  name = 'u_rgbaImage';
  var Integer smpLocation = glGetAttribLocation(shaderProgram.programId, name);

  // TODO: Check these Attrib sets. Do we need them all?
  glPushAttrib(GL_DEPTH_BUFFER_BIT | GL_VIEWPORT_BIT | GL_TEXTURE_BIT);
  
  // Set the sampler
  glEnable(GL_TEXTURE_2D);
  glDisable(GL_DEPTH_TEST);
  glDisable(GL_CULL_FACE);

  shaderProgram.loadIntegerUniform(smpLocation, textureUnit);

  // Draw a quad in the upper left with debugging info
  var Vec3 p[4];
  p[0] = Vec3(-1.0, 1.0, 0.0);
  p[1] = Vec3(1.0, 1.0, 0.0);
  p[2] = Vec3(1.0, - 1.0, 0.0);
  p[3] = Vec3(-1.0, - 1.0, 0.0);
  var Vec2 t[4];
  t[0] = Vec2(0.0, 0.0);
  t[1] = Vec2(1.0, 0.0);
  t[2] = Vec2(1.0, 1.0);
  t[3] = Vec2(0.0, 1.0);
  var Integer idx[6];
  idx[0] = 0; idx[1] = 2; idx[2] = 1;
  idx[3] = 0; idx[4] = 3; idx[5] = 2;

  var Data NULL;

  var Size bufferID0;
  var Size bufferID1;
  var Size bufferID2;
  var Size bufferIDArray[];
  bufferIDArray.resize(1);
  glGenBuffers(1, bufferIDArray);
  bufferID0 = bufferIDArray[0];
  glGenBuffers(1, bufferIDArray);
  bufferID1 = bufferIDArray[0];
  glGenBuffers(1, bufferIDArray);
  bufferID2 = bufferIDArray[0];

  glBindBuffer(GL_ARRAY_BUFFER, bufferID0);
  glBufferData(GL_ARRAY_BUFFER, p.dataSize(), p.data(), GL_STATIC_DRAW);
  glEnableVertexAttribArray(posLocation);
  glVertexAttribPointer(posLocation, 3, GL_FLOAT, GL_FALSE, 0, NULL);

  glBindBuffer(GL_ARRAY_BUFFER, bufferID1);
  glBufferData(GL_ARRAY_BUFFER, t.dataSize(), t.data(), GL_STATIC_DRAW);
  glEnableVertexAttribArray(texLocation);
  glVertexAttribPointer(texLocation, 2, GL_FLOAT, GL_FALSE, 0, NULL);

  glBindBuffer(GL_ARRAY_BUFFER, bufferID2);
  glBufferData(GL_ARRAY_BUFFER, idx.dataSize(), idx.data(), GL_STATIC_DRAW);
  glBindBuffer(GL_ARRAY_BUFFER, 0);

  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, bufferID2);
  glDrawElements(GL_TRIANGLES, idx.size(), GL_UNSIGNED_INT, NULL);
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

  glPopAttrib();
  // report("<<<renderTextureToView");
}


function OGLTexture2D.createSpriteTexture(
  io Integer res,
  io Integer textureUnit
) {
  if (!self.bufferID && res > 0) {
    var RGBA texData[];
    texData.resize(res * res);

    var Size idx = 0;
    var Scalar dt = 2.0 / Scalar(res);
    var Scalar ty = - 1.0;
    for (var Integer y = 0; y < res; y++) {
      var Scalar tx = - 1.0;
      for (var Integer x = 0; x < res; x++) {
        var Scalar t = sqrt(tx * tx + ty * ty);
        if (t > 1.0) t = 1.0;
          t = 2.0 * t * t * t - 3.0 * t * t + 1.0;
        texData[idx].r = texData[idx].g = texData[idx].b = texData[idx].a = Byte(t * 255.0);
        idx++;
        tx += dt;
      }
      ty += dt;
    }

    var Size buffers[];
    buffers.push(Size(self.bufferID));
    glGenTextures(1, buffers);
    glActiveTexture(GL_TEXTURE0 + textureUnit);
    glBindTexture(GL_TEXTURE_2D, self.bufferID);
    glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, 1);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, res, res, 0, GL_RGBA, GL_UNSIGNED_BYTE, texData.data());
  }
  else {
    glActiveTexture(GL_TEXTURE0 + textureUnit);
    glBindTexture(GL_TEXTURE_2D, self.bufferID);
  }
}

function OGLTexture2D.createErrorTexture(
  io Integer textureUnit
) {
  if (!self.bufferID) {
    var RGBA texData[];
    texData.resize(1);
    texData[0].r = 1.0;
    texData[0].g = texData[0].b = texData[0].a = 0.0;
    var Size buffers[];
    buffers.resize(1);
    glGenTextures(1, buffers);
    self.bufferID = buffers[0];
    glActiveTexture(GL_TEXTURE0 + textureUnit);
    glBindTexture(GL_TEXTURE_2D, self.bufferID);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 1, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, texData.data());
  }
  else {
    glActiveTexture(GL_TEXTURE0 + textureUnit);
    glBindTexture(GL_TEXTURE_2D, self.bufferID);
  }
}
